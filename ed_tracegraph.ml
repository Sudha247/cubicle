(* open Ed_graph *)

(* let graph_trace = Queue.create () *)

(* type model_t = Edge of (G.V.t * G.V.t) | Node of G.V.t | UnsafeNode of G.V.t *)

(* let model = Queue.create ()  *)

(* let m = Mutex.create () *)

(* let m_end = Mutex.create () *)

(* let m_model = Mutex.create () *)

(* let c = Condition.create () *)

(* let c_model = Condition.create ()  *)

(* let c_end = Condition.create () *)

(* module Var_L = Map.Make (String) *)

(* let var_l = ref [] *)

(* let end_show_tree = ref false *)

(* let end_load_graph = ref false *)

(* let root = ref None *)

(* exception End_trace *)

(* exception KillThread *)

(* let kill_thread = ref false *)

(* let cpt = ref 1 *)

(* module HTString  = *)
(*   (struct *)
(*     type t = string *)
(*     let equal x y = (String.trim x) = (String.trim y) *)
(*     let hash x  = Hashtbl.hash x *)
(*    end) *)

(* module HT = Hashtbl.Make (HTString) *)

(* let ht = HT.create 500 *)
        
(* let split_node_info x m v changed_l  = *)
(*   let var_find before  s = *)
(*     List.fold_left (fun acc x -> *)
(*       if x = s then *)
(*         ((G.V.label v).num_label <- (G.V.label v).num_label ^ "\n" ^ before  ; true) *)
(*       else *)
(*         try *)
(*           let pos = Str.search_forward (Str.regexp "\\[") s 0 in *)
(*           let array_name = Str.global_replace (Str.regexp "[\n| ]+") "" *)
(*             (Str.string_before s pos) in *)
(*           if array_name = x then *)
(*             ((G.V.label v).num_label <- (G.V.label v).num_label ^ "\n" ^ before ; true) *)
(*           else acc *)
(*         with Not_found -> acc ) false !var_l *)
(*   in *)
(*   (let pos = Str.search_forward (Str.regexp "[=|<>]") x 0 in *)
(*    let before = Str.global_replace (Str.regexp "[\n| ]+") "" *)
(*      (Str.string_before x pos) in *)
(*    let after =  Str.global_replace (Str.regexp "[\n| ]+") "" *)
(*      (Str.string_after x (pos + 1)) in *)
(*    let m = *)
(*      try *)
(*        (let a = Var_Map.find before m in *)
(*         if a <> after && var_find before before then *)
(*           ((G.V.label v).vertex_mode <- VarChange; *)
(*            m) *)
(*         else *)
(*           m) *)
(*      with Not_found -> m in *)
(*    (before, after, m)) *)
    
(* let rec build_map m v l  = *)
(*   let changed_l = ref "" in *)
(*   match l with *)
(*     |[] -> m *)
(*     |y::[] -> *)
(*       (match Str.split (Str.regexp "\n") (String.trim y) with *)
(*         |[] -> failwith "pb format trace 2" *)
(*         |x::_ -> *)
(*           (try *)
(*              let before, after, m = split_node_info x m v changed_l  in *)
(*              Var_Map.add before after m *)
(*            with Not_found -> failwith "erreur build map")) *)
(*     |x::s -> *)
(*       try *)
(*         let before, after, m = split_node_info x m v changed_l in *)
(*         build_map (Var_Map.add before after m) v s *)
(*       with Not_found -> failwith "erreur build map" *)
        
        
(* let rec node_name  = function *)
(*   |[] -> "" *)
(*   |x::[] -> *)
(*     (match Str.split (Str.regexp "\n") (String.trim x) with *)
(*       |[] -> failwith "pb format trace 2" *)
(*       |y::_ ->  y) *)
(*   |x::s -> (String.trim x)^"\n"^(node_name s) *)
    
(* let link_node before v after = *)
(*   try *)
(*     (let arrow_pos = Str.search_forward (Str.regexp "->") before 0 in *)
(*      let transition = Str.string_before before arrow_pos in *)
(*      let node = Str.global_replace (Str.regexp "[\n| ]+") "" *)
(*        (Str.string_after before (arrow_pos + 2)) in *)
(*      let n = HT.find ht node in *)
(*      let e = G.E.create n (make_edge_info_label transition true) v in *)
(*      (G.V.label v).var_map <- build_map (G.V.label n).var_map v after; *)
(*      G.add_edge_e !graph e; *)
(*      Mutex.lock m_model; *)
(*      Queue.push (Edge(n,v)) model ; *)
(*      Condition.signal c_model; *)
(*      Mutex.unlock m_model; *)
(*      (\* ignore (Model.add_edge n v) *\)) *)
(*   with Not_found -> *)
(*     match !root with *)
(*       |None -> failwith "pb None" *)
(*       |Some x -> *)
(*         let e = G.E.create x (make_edge_info_label "" true) v in *)
(*         (G.V.label v).var_map <- build_map (Var_Map.empty) v after; *)
(*         (G.V.label v).vertex_mode <- Unsafe; *)
(*         G.add_edge_e !graph e; *)
(*         Mutex.lock m_model; *)
(*         Queue.push (Edge(x,v)) model; *)
(*         Condition.signal c_model; *)
(*         Mutex.unlock m_model *)
(* (\* ignore (Model.add_edge x v) *\) *)
          
(* let create_node s unsafe_l  = *)
(*   let pos = Str.search_forward (Str.regexp "=") s 0 in *)
(*   let before = Str.global_replace (Str.regexp "[\n| ]+") "" *)
(*     (String.trim (Str.string_before s pos)) in *)
(*   let after = Str.split (Str.regexp "&&") (Str.string_after s (pos + 1)) in *)
(*   let name = node_name after in *)
(*   let v = *)
(*     if !cpt = 1 && unsafe_l = 1  then *)
(*       (let vertex = G.V.create (make_node_info  (string_of_int !cpt)  name true) in *)
(*        root := Some vertex; *)
(*        Mutex.lock m_model; *)
(*        Queue.push (UnsafeNode(vertex)) model; *)
(*        Condition.signal c_model; *)
(*        Mutex.unlock m_model; *)
(*        (\* ignore (Model.add_vertex_unsafe vertex); *\) *)
(*        vertex) *)
(*     else if !cpt <= unsafe_l then *)
(*       (let vertex = G.V.create (make_node_info  (string_of_int !cpt)  name true) in *)
(*        Mutex.lock m_model; *)
(*        Queue.push (UnsafeNode(vertex)) model; *)
(*        Condition.signal c_model; *)
(*        Mutex.unlock m_model; *)
(*        (\* ignore (Model.add_vertex_unsafe vertex); *\) *)
(*        vertex) *)
(*     else *)
(*       (let vertex = G.V.create (make_node_info  (string_of_int !cpt)  name true) in *)
(*        Mutex.lock m_model; *)
(*        Queue.push (Node(vertex)) model; *)
(*        Condition.signal c_model; *)
(*         Mutex.unlock m_model; *)
(*        (\* ignore (Model.add_vertex vertex); *\) *)
(*        vertex) in *)
(*   link_node before v after; *)
(*   (G.V.label v).label <- (G.V.label v).num_label; *)
(*   HT.add ht before v; *)
(*   G.add_vertex !graph v; *)
(*   incr cpt *)
(*   (\* Ed_display.add_node canvas_root v; *\) *)
(*   (\* !set_vertex_event_fun v; *\) *)
(*   (\* let tor = make_turtle !origine 0.0 in *\) *)
(*   (\* draw tor canvas_root; *\) *)
(*   (\* incr cpt; *\) *)
(*   (\* Thread.delay 0.001 *\) *)

(* let rec list_to_node curr_node unsafe_l = function *)
(*   |[] -> () *)
(*   |[x] -> *)
(*     (try *)
(*        let pos = Str.search_forward (Str.regexp "==") x 0 in *)
(*        let before = Str.string_before x pos in *)
(*        create_node before unsafe_l; *)
(*        raise End_trace *)
(*      with Not_found -> (curr_node := !curr_node ^ x)) *)
(*   |x::s -> *)
(*     curr_node := !curr_node ^ x; *)
(*     create_node !curr_node unsafe_l; *)
(*     curr_node := ""; *)
(*     list_to_node curr_node unsafe_l s *)
      
(* let rec build_node curr_node str unsafe_l  = *)
(*   let str_l = Str.split (Str.regexp "node [0-9]+:") str in *)
(*   match str_l with *)
(*     |[] -> () *)
(*     |[x] -> *)
(*       (if !curr_node <> "" then *)
(*           create_node !curr_node unsafe_l; *)
(*        curr_node := x) *)
(*     |x::s -> *)
(*       list_to_node curr_node unsafe_l str_l *)

(* let load_graph unsafe_l = *)
(*   try *)
(*     let curr_node = ref "" in *)
(*     while true do *)
(*       try *)
(*         if !kill_thread then raise KillThread; *)
(*         Mutex.lock m; *)
(*         while Queue.length graph_trace = 0 do *)
(*           Condition.wait c m *)
(*         done; *)
(*         let str = Queue.pop graph_trace in *)
(*         Mutex.unlock m; *)
(*         if Str.string_match (Str.regexp "==") str 0 then *)
(*           (build_node curr_node str unsafe_l ; *)
(*            raise End_trace) *)
(*         else if Str.string_match (Str.regexp "node [0-9]+:") str 0 then *)
(*           build_node curr_node str unsafe_l *)
(*         else *)
(*           curr_node := !curr_node ^ str *)
(*       with Queue.Empty ->  Mutex.unlock m; *)
(*     done *)
(*   with *)
(*     |End_trace -> (Mutex.lock m_end; end_load_graph := true; Condition.signal c_end; Mutex.unlock m_end) *)
(*     |KillThread -> () *)


(* let show_tree file  = *)
(*   let ic = Unix.open_process_in ("cubicle -nocolor -v "^file) in *)
(*   try *)
(*     while true do *)
(*       if !kill_thread then raise KillThread; *)
(*       let s = input_line ic in *)
(*       Mutex.lock m; *)
(*       Queue.push (s^"\n") graph_trace; *)
(*       Condition.signal c; *)
(*       Mutex.unlock m; *)
(*     done *)
(*   with *)
(*     |End_of_file -> *)
(*       (ignore (Unix.close_process_in ic); end_show_tree := true) *)
(*     |KillThread -> *)
(*       ignore (Unix.close_process_in ic) *)
        

