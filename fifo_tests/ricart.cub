(* Ricart Agrawala mutual exclusion algorithm *)

(*
Without the Ghost variable:
Spurious trace: try(#2) -> sendreq(#2, #1) -> req_ack2(#2, #1) -> try(#1) ->
              recvperm(#1, #2) -> enter(#1) -> unsafe[2]

With the Ghost variable:
Unsafe trace: try(#2) -> sendreq(#2, #1) -> req_ack2(#2, #1) -> try(#1) ->
              recvperm(#1, #2) -> sendreq(#1, #2) -> req_ack2(#1, #2) ->
              recvperm(#2, #1) -> enter(#1) -> enter(#2) -> unsafe[1]
Cubicle runs forever to check that this a valid trace.
I think it is valid: oops, there is a bug !
*)

type location = Out | Trying | In | Exiting

array State[proc] : location
array Clock[proc] : int (* local clock of each site *)
array Last[proc] : int  (* time of the last request of this site *)
array Request[proc,proc] : bool (* for i, the sites to which it must send a request *)
array Wait[proc,proc] : bool (* for i, the sites from which it expects a permission *)
array Delayed[proc,proc] : bool (* for i, the sites that have requested its permission *)

array Ghost[proc] : int (* To count waited permissions. Unncessary except to avoid a spurious trace *)

chan CRequest[ASYNC] : int
chan CPermission[ASYNC] : proc

(****************************************************************)

init(i j) {
 State[i] = Out && Clock[i] = 0 && Last[i] = 0
 && Request[i,j] = False && Wait[i,j] = False && Delayed[i,j] = False
 && Ghost[i] = 0
}

(****************************************************************)

unsafe(i j) { State[i] = In && State[j] = In }

unsafe(i j) { State[i] <> Trying && Request[i,j] = True }

unsafe(i j) { State[i] <> Trying && Wait[i,j] = True }

unsafe(i j) { State[i] = Out && Delayed[i,j] = True }

unsafe(i) { Last[i] > Clock[i] }

(****************************************************************)

transition try([i])
requires { State[i] = Out }
{
 State[i] := Trying;
 Clock[i] := Clock[i] + 1;
 Last[i] := Clock[i] + 1;
 Request[x,y] := case
                 | x = i && y <> i : True
              (* | x = i && y = i : False *)
                 | _ : Request[x,y] ;
 Wait[x,y] := case
              | x = i && y <> i : True
           (* | x = i && y = i : False *)
              | _ : Wait[x,y] ;
 Ghost[i] := 0;
}

transition sendreq([i] j)
requires { State[i] = Trying && Request[i,j] = True }
{
 Request[i,j] := False;
 CRequest'j!Last[i];
 Ghost[i] := Ghost[i] + 1;
}

(****************************************************************)

transition req_ack1a([i] j)   (* request while not interested => give permission *)
requires { State[i] = Out && CRequest'j? <= Clock[i] }
{
 CPermission'j!i;
}

transition req_ack1b([i] j)   (* request while not trying => give permission *)
requires { State[i] = Out && Clock[i] <= CRequest'j? }
{
 Clock[i] := CRequest'j? + 1;
 CPermission'j!i;
}

transition req_ack2([i] j)   (* request while trying with greater date => give permission *)
requires { State[i] = Trying && CRequest'j? <= Last[i] }
{
 CPermission'j!i;
}

transition req_nack1([i] j)   (* request while trying with lower date => delay *)
requires { State[i] = Trying && Last[i] <= CRequest'j? }
{
 Delayed[i,j] := True;
}

transition req_nack2([i] j)   (* request while in => delay (date is necessarily greater) *)
requires { State[i] = In && Last[i] <= CRequest'j? }
{
 Delayed[i,j] := True;
}

(****************************************************************)

transition recvperm([i] j)     (* receive a permission *)
requires { State[i] = Trying && Wait[i,j] = True && CPermission? = j }
{
 Wait[i,j] := False;
 Ghost[i] := Ghost[i] - 1;
}

transition enter([i])       (* can enter when there is no waiting permission *)
requires { State[i] = Trying && Ghost[i] = 0 && forall_other j. Wait[i,j] = False }
{
 State[i] := In
}

(****************************************************************)

transition exit([i])
requires { State[i] = In }
{
 State[i] := Exiting
}

transition exiting1([i] j)
requires { State[i] = Exiting && Delayed[i,j] = True }
{
 Delayed[i,j] := False;
 CPermission'j!i
}

transition exiting2([i])
requires { State[i] = Exiting && forall_other j. Delayed[i,j] = False }
{
 State[i] := Out
}

(****************************************************************)
