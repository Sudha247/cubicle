(* Ricart Agrawala mutual exclusion algorithm *)

(*
With a Ghost variable to count waited permission
*)

type location = Out | Trying | In | Exiting

array State[proc] : location
array Clock[proc] : int (* local clock of each site *)
array Last[proc] : int  (* time of the last request of this site *)
array Request[proc,proc] : bool (* for i, the sites to which it must send a request *)
array Wait[proc,proc] : bool (* for i, the sites from which it expects a permission *)
array Delayed[proc,proc] : bool (* for i, the sites that have requested its permission *)

array Ghost[proc] : int (* To count waited permissions. Unncessary except to ease verification *)

(* chan CRequest[1,1] : int *)
(* chan CPermission[1,1] : proc *)
chan CRequest[ASYNC] : int
chan CPermission[ASYNC] : proc

(****************************************************************)

init(i j) {
 State[i] = Out && Clock[i] = 0 && Last[i] = 0
 && Request[i,j] = False && Wait[i,j] = False && Delayed[i,j] = False
 && Ghost[i] = 0
}

(****************************************************************)

unsafe(i j) { State[i] = In && State[j] = In }

unsafe(i j) { State[i] <> Trying && Request[i,j] = True }

unsafe(i j) { State[i] <> Trying && Wait[i,j] = True }

unsafe(i j) { State[i] = Out && Delayed[i,j] = True }

unsafe(i) { Last[i] > Clock[i] }

(****************************************************************)

transition try([i])
requires { State[i] = Out }
{
 State[i] := Trying;
 Last[i] := Clock[i];
 Clock[i] := Clock[i] + 1;
 Request[x,y] := case
                 | x = i && y <> i : True
              (* | x = i && y = i : False *)
                 | _ : Request[x,y] ;
 Wait[x,y] := case
              | x = i && y <> i : True
           (* | x = i && y = i : False *)
              | _ : Wait[x,y] ;
 Ghost[i] := 0;
}

transition sendreq([i] j)
requires { State[i] = Trying && Request[i,j] = True }
{
 Request[i,j] := False;
 CRequest'j!Last[i];
 Ghost[i] := Ghost[i] + 1;
}

(****************************************************************)

(* When receiving a request, Clock[i] must be updated with max(Clock[i], CRequest? + 1).
* In Cubicle, this is done by splitting the transitions in two parts. *)

transition req_ack1a([i] j)   (* request while not trying => give permission *)
requires { State[i] = Out && Clock[i] <= CRequest'j? }
{
 CPermission'j!i;
 Clock[i] := CRequest'j? + 1;
}

transition req_ack1b([i] j)   (* request while not interested => give permission *)
requires { State[i] = Out && CRequest'j? < Clock[i] }
{
 CPermission'j!i;
}

transition req_ack2a([i] j)   (* request while trying with greater date => give permission *)
requires { State[i] = Trying && CRequest'j? < Last[i] }
{
 CPermission'j!i;
 (* Cock[i] > Last[i] so it's already > CRequest'j *)
}
transition req_ack2b([i] j)   (* request while trying with greater date => give permission *)
requires { State[i] = Trying && CRequest'j? = Last[i] && j < i }
{
 CPermission'j!i;
 (* Cock[i] > Last[i] so it's already > CRequest'j *)
}

transition req_nack1a([i] j)   (* request while trying with lower date => delay *)
requires { State[i] = Trying && Last[i] < CRequest'j? && Clock[i] <= CRequest'j? }
{
 Delayed[i,j] := True;
 Clock[i] := CRequest'j? + 1;
}
transition req_nack1b([i] j)   (* request while trying with lower date => delay *)
requires { State[i] = Trying && Last[i] < CRequest'j? && CRequest'j? < Clock[i] }
{
 Delayed[i,j] := True;
}
transition req_nack1c([i] j)   (* request while trying with lower date => delay *)
requires { State[i] = Trying && Last[i] = CRequest'j? && i < j  && Clock[i] <= CRequest'j? }
{
 Delayed[i,j] := True;
 Clock[i] := CRequest'j? + 1;
}
transition req_nack1d([i] j)   (* request while trying with lower date => delay *)
requires { State[i] = Trying && Last[i] = CRequest'j? && i < j  && CRequest'j? < Clock[i] }
{
 Delayed[i,j] := True;
}

transition req_nack2a([i] j)   (* request while in => delay. *)
                              (* Last[i] <= CRequest'j? is necessarily true *)
requires { State[i] = In && Clock[i] <= CRequest'j? }
{
 Delayed[i,j] := True;
 Clock[i] := CRequest'j? + 1;
}
transition req_nack2b([i] j)   (* request while in => delay *)
                              (* Last[i] <= CRequest'j? is necessarily true *)
requires { State[i] = In && CRequest'j? < Clock[i] }
{
 Delayed[i,j] := True;
}

(****************************************************************)

transition recvperm([i] j)     (* receive a permission *)
requires { State[i] = Trying && Wait[i,j] = True && CPermission? = j }
{
 Wait[i,j] := False;
 Ghost[i] := Ghost[i] - 1;
}

transition enter([i])       (* can enter when there is no waiting permission *)
requires { State[i] = Trying && Ghost[i] = 0 && forall_other j. Wait[i,j] = False }
{
 State[i] := In
}

(****************************************************************)

transition exit([i])
requires { State[i] = In }
{
 State[i] := Exiting
}

transition exiting1([i] j)
requires { State[i] = Exiting && Delayed[i,j] = True }
{
 Delayed[i,j] := False;
 CPermission'j!i
}

transition exiting2([i])
requires { State[i] = Exiting && forall_other j. Delayed[i,j] = False }
{
 State[i] := Out
}

(****************************************************************)
