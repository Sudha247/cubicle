(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.

(* Why3 assumption *)
Definition unit := unit.

(* Why3 assumption *)
Inductive ref (a:Type) {a_WT:WhyType a} :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a] [a_WT]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Axiom structure : Type.
Parameter structure_WhyType : WhyType structure.
Existing Instance structure_WhyType.

Parameter infix_breq: structure -> t -> Prop.

Parameter ffalse: t.

Parameter ttrue: t.

Parameter neg: t -> t.

Parameter and: t -> t -> t.

Parameter or: t -> t -> t.

Axiom true_false : ~ (ttrue = ffalse).

(* Why3 assumption *)
Definition sat (f:t): Prop := exists m:structure, (infix_breq m f).

(* Why3 assumption *)
Definition valid (f:t): Prop := ~ (sat (neg f)).

Axiom negneg : forall (f:t), ((neg (neg f)) = f).

Axiom and_a : forall (f1:t) (f2:t) (f3:t), ((and (and f1 f2) f3) = (and f1
  (and f2 f3))).

Axiom and_c : forall (f1:t) (f2:t), ((and f1 f2) = (and f2 f1)).

Axiom or_a : forall (f1:t) (f2:t) (f3:t), ((or (or f1 f2) f3) = (or f1 (or f2
  f3))).

Axiom or_c : forall (f1:t) (f2:t), ((or f1 f2) = (or f2 f1)).

Axiom distr_and : forall (f1:t) (f2:t) (f3:t), ((and f1 (or f2
  f3)) = (or (and f1 f2) (and f1 f3))).

Axiom distr_or : forall (f1:t) (f2:t) (f3:t), ((or f1 (and f2
  f3)) = (and (or f1 f2) (or f1 f3))).

Axiom neutral_and : forall (f:t), ((and f ttrue) = f).

Axiom neutral_or : forall (f:t), ((or f ffalse) = f).

Axiom absorb_and : forall (f:t), ((and f ffalse) = ffalse).

Axiom absorb_or : forall (f:t), ((or f ttrue) = ttrue).

Axiom ttrue_valid : (valid ttrue).

Axiom ffaslse_invalid : ~ (valid ffalse).

Axiom ttrue_sat : (sat ttrue).

Axiom ffalse_unsat : ~ (sat ffalse).

Axiom sat_or : forall (f1:t) (f2:t), (sat (or f1 f2)) <-> ((sat f1) \/ (sat
  f2)).

Axiom forget_subsumed : forall (f:t) (v:t), (valid (or (neg f) v)) -> ((or f
  v) = v).

Axiom classic_neg : forall (f:t), ((or (neg f) f) = ttrue).

Axiom set : forall (a:Type) {a_WT:WhyType a}, Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

(* Why3 assumption *)
Definition infix_eqeq {a:Type} {a_WT:WhyType a} (s1:(set a)) (s2:(set
  a)): Prop := forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)), (infix_eqeq s1 s2) -> (s1 = s2).

(* Why3 assumption *)
Definition subset {a:Type} {a_WT:WhyType a} (s1:(set a)) (s2:(set
  a)): Prop := forall (x:a), (mem x s1) -> (mem x s2).

Axiom subset_refl : forall {a:Type} {a_WT:WhyType a}, forall (s:(set a)),
  (subset s s).

Axiom subset_trans : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)) (s3:(set a)), (subset s1 s2) -> ((subset s2 s3) -> (subset s1
  s3)).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, (set a).

(* Why3 assumption *)
Definition is_empty {a:Type} {a_WT:WhyType a} (s:(set a)): Prop :=
  forall (x:a), ~ (mem x s).

Axiom empty_def1 : forall {a:Type} {a_WT:WhyType a}, (is_empty (empty :(set
  a))).

Axiom mem_empty : forall {a:Type} {a_WT:WhyType a}, forall (x:a), ~ (mem x
  (empty :(set a))).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> (set a).

Axiom add_def1 : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (y:a),
  forall (s:(set a)), (mem x (add y s)) <-> ((x = y) \/ (mem x s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> (set a).

Axiom remove_def1 : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (y:a)
  (s:(set a)), (mem x (remove y s)) <-> ((~ (x = y)) /\ (mem x s)).

Axiom subset_remove : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (s:(set
  a)), (subset (remove x s) s).

Parameter union: forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> (set
  a).

Axiom union_def1 : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)) (x:a), (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter: forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> (set
  a).

Axiom inter_def1 : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)) (x:a), (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff: forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> (set
  a).

Axiom diff_def1 : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)) (x:a), (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)), (subset (diff s1 s2) s1).

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_def : forall {a:Type} {a_WT:WhyType a}, forall (s:(set a)),
  (~ (is_empty s)) -> (mem (choose s) s).

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg : forall {a:Type} {a_WT:WhyType a}, forall (s:(set a)),
  (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty : forall {a:Type} {a_WT:WhyType a}, forall (s:(set a)),
  ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add : forall {a:Type} {a_WT:WhyType a}, forall (x:a),
  forall (s:(set a)), (~ (mem x s)) -> ((cardinal (add x
  s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove : forall {a:Type} {a_WT:WhyType a}, forall (x:a),
  forall (s:(set a)), (mem x s) -> ((cardinal s) = (1%Z + (cardinal (remove x
  s)))%Z).

Axiom cardinal_subset : forall {a:Type} {a_WT:WhyType a}, forall (s1:(set a))
  (s2:(set a)), (subset s1 s2) -> ((cardinal s1) <= (cardinal s2))%Z.

Axiom cardinal1 : forall {a:Type} {a_WT:WhyType a}, forall (s:(set a)),
  ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) -> (x = (choose s)).

Parameter pre: t -> t.

Axiom pre_false : ((pre ffalse) = ffalse).

Parameter pre_star: t -> t.

Axiom pre_star_def1 : forall (f:t), (valid (or (neg f) (pre_star f))).

Axiom pre_star_def4 : forall (f:t), ((or (pre_star (pre f))
  f) = (pre_star f)).

Axiom pre_star_false : ((pre_star ffalse) = ffalse).

Axiom pre_star_and : forall (f1:t) (f2:t), ((pre_star (and f1
  f2)) = (and (pre_star f1) (pre_star f2))).

Axiom pre_star_or : forall (f1:t) (f2:t), ((pre_star (or f1
  f2)) = (or (pre_star f1) (pre_star f2))).

(* Why3 assumption *)
Definition reachable (init:t) (f:t): Prop := (sat (and (pre_star f) init)).

Axiom directly_reachable : forall (init:t) (f:t), (sat (and init f)) ->
  (reachable init f).

Axiom false_unreachable : forall (init:t), ~ (reachable init ffalse).

Axiom reachable_or : forall (f1:t) (f2:t) (init:t), (reachable init (or f1
  f2)) <-> ((reachable init f1) \/ (reachable init f2)).

(* Why3 assumption *)
Inductive t1 :=
  | mk_t : t -> (set t) -> t1.
Axiom t1_WhyType : WhyType t1.
Existing Instance t1_WhyType.

(* Why3 assumption *)
Definition elts (v:t1): (set t) := match v with
  | (mk_t x x1) => x1
  end.

(* Why3 assumption *)
Definition formula (v:t1): t := match v with
  | (mk_t x x1) => x
  end.

(* Why3 assumption *)
Inductive result :=
  | Safe : result
  | Unsafe : result.
Axiom result_WhyType : WhyType result.
Existing Instance result_WhyType.

(* Why3 goal *)
Theorem WP_parameter_bwd : forall (init:t) (theta:t), forall (visited:t),
  (visited = ffalse) -> forall (rho:(set t)) (rho1:t), ((rho1 = ffalse) /\
  (rho = (empty :(set t)))) -> ((~ (sat (and init theta))) ->
  forall (visited1:t), (visited1 = (or theta visited)) -> forall (rho2:(set
  t)) (rho3:t), ((rho3 = (or (pre theta) rho1)) /\ (rho2 = (add (pre theta)
  rho))) -> forall (rho4:(set t)) (rho5:t) (visited2:t), ((~ (sat (and init
  visited2))) /\ (((pre_star visited2) = (or visited2 (pre_star rho5))) /\
  ((pre_star theta) = (or visited2 (pre_star rho5))))) -> forall (o:bool),
  ((o = true) <-> ((is_empty rho4) /\ (rho5 = ffalse))) -> ((~ (o = true)) ->
  forall (old_q:t) (old_q1:(set t)), ((old_q = rho5) /\ (old_q1 = rho4)) ->
  forall (rho6:(set t)) (rho7:t), let phi := (choose rho4) in (((~ (is_empty
  rho4)) /\ ((rho6 = (remove phi rho4)) /\ ((valid (or (neg phi) rho5)) /\
  (rho7 = (and (neg phi) rho5))))) -> ((~ (sat (and init phi))) -> ((~ (valid
  (or (neg phi) visited2))) -> forall (visited3:t), (visited3 = (or phi
  visited2)) -> forall (rho8:(set t)) (rho9:t), ((rho9 = (or (pre phi)
  rho7)) /\ (rho8 = (add (pre phi) rho6))) -> (((or visited3
  (pre_star rho9)) = (or visited2 (pre_star (and ttrue (or phi old_q))))) ->
  ((~ (sat (and init visited3))) -> ((pre_star visited3) = (or visited3
  (pre_star rho9)))))))))).
intros init theta visited h1 rho rho1 (h2,h3) h4 visited1 h5 rho2
        rho3 (h6,h7) rho4 rho5 visited2 (h8,(h9,h10)) o h11 h12 old_q old_q1
        (oqdef,od1def) rho6 rho7 phi (h13,(h14,(hnew,h15)))
        h16 h17 visited3 h18 rho8 rho9 (h19,h20) assert4 h21.


rewrite h19.
rewrite h18.
rewrite h15.
rewrite pre_star_or with (f1 := pre phi).
rewrite or_c with (f1 := phi).
rewrite or_a with (f1 := visited2).
rewrite <- or_a with (f1 := phi).
rewrite or_c with (f1 := phi).
rewrite pre_star_def4.
rewrite <- pre_star_or.
rewrite distr_or.
rewrite or_c with (f2 := neg phi).
rewrite classic_neg.
rewrite and_c.
rewrite neutral_and.
rewrite pre_star_or.
rewrite h9.
rewrite pre_star_or.
(*
assert (valid (or (neg phi) (pre_star phi))).
apply pre_star_def1.
apply forget_subsumed in H.
rewrite <- H.
*)
rewrite or_a.
(* rewrite H. *)
rewrite or_c with (f2 := pre_star phi).
reflexivity.

Qed.


