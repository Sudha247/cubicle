
number_procs 2

type loc = L1 | L2 | L3 | L4 | L5 | L6 | L7 | L8 | L9 | L10 | L11

(* Program counters *)
array PC[proc] : loc

(* Thread local variables *)
array WantL[proc] : bool
array TurnL[proc] : int

(* Global variables *)
weak array Want[proc] : bool
weak var Turn : int

init (p) { PC[p] = L1 && Want[p] = False && WantL[p] = False && Turn = 0 }

(* Unsafe state reachable only in TSO *)
unsafe (p1 p2) { PC[p1] = L10 && PC[p2] = L10 }


(* Thread 1 *)

transition t1_L1_L2_store_Want1_True (p)
requires { p = #1 && PC[p] = L1 }
{ PC[p] := L2; write(p, Want[p], True) }

transition t1_L2_L3_load_Want2 (p)
fences (p)
requires { p = #1 && PC[p] = L2 }
{ PC[p] := L3; WantL[p] := read(p, Want[#2]) }

transition t1_L3_L4_Want2_True (p)
requires { p = #1 && PC[p] = L3 && WantL[p] = True }
{ PC[p] := L4; write(p, Turn, 2) }

transition t1_L3_L10_Want2_False (p)
requires { p = #1 && PC[p] = L3 && WantL[p] = False }
{ PC[p] := L10 }

transition t1_L4_L5_load_Turn (p)
requires { p = #1 && PC[p] = L4 }
{ PC[p] := L5; TurnL[p] := read(p, Turn) }

transition t1_L5_L6_Turn_Other (p)
requires { p = #1 && PC[p] = L5 && TurnL[p] <> 0 }
{ PC[p] := L6 }

transition t1_L5_L2_Turn_Self (p)
requires { p = #1 && PC[p] = L5 && TurnL[p] = 0 }
{ PC[p] := L2 }

transition t1_L6_L7_store_Want1_False (p)
requires { p = #1 && PC[p] = L6 }
{ PC[p] := L7; write(p, Want[p], False) }

transition t1_L7_L8_load_Turn (p)
requires { p = #1 && PC[p] = L7 }
{ PC[p] := L8; TurnL[p] := read(p, Turn) }

transition t1_L8_L7_Turn_Other (p)
requires { p = #1 && PC[p] = L8 && TurnL[p] <> 0 }
{ PC[p] := L7 }

transition t1_L8_L9_Turn_Self (p)
requires { p = #1 && PC[p] = L8 && TurnL[p] = 0 }
{ PC[p] := L9 }

transition t1_L9_L2_store_Want1_True (p)
requires { p = #1 && PC[p] = L9 }
{ PC[p] := L2; write(p, Want[p], True) }

(* Critical section *)

transition t1_L10_L11_store_Turn_Other (p)
requires { p = #1 && PC[p] = L10 }
{ PC[p] := L11; write(p, Turn, 1) }

transition t1_L11_L1_store_Want1_False (p)
requires { p = #1 && PC[p] = L11 }
{ PC[p] := L1; write(p, Want[p], False) }


(* Thread 2 *)

transition t2_L1_L2_store_Want2_True (p)
requires { p = #2 && PC[p] = L1 }
{ PC[p] := L2; write(p, Want[p], True) }

transition t2_L2_L3_load_Want1 (p)
fences (p)
requires { p = #2 && PC[p] = L2 }
{ PC[p] := L3; WantL[p] := read(p, Want[#1]) }

transition t2_L3_L4_Want1_True (p)
requires { p = #2 && PC[p] = L3 && WantL[p] = True }
{ PC[p] := L4; write(p, Turn, 2) }

transition t2_L3_L10_Want1_False (p)
requires { p = #2 && PC[p] = L3 && WantL[p] = False }
{ PC[p] := L10 }

transition t2_L4_L5_load_Turn (p)
requires { p = #2 && PC[p] = L4 }
{ PC[p] := L5; TurnL[p] := read(p, Turn) }

transition t2_L5_L6_Turn_Other (p)
requires { p = #2 && PC[p] = L5 && TurnL[p] <> 1 }
{ PC[p] := L6 }

transition t2_L5_L2_Turn_Self (p)
requires { p = #2 && PC[p] = L5 && TurnL[p] = 1 }
{ PC[p] := L2 }

transition t2_L6_L7_store_Want1_False (p)
requires { p = #2 && PC[p] = L6 }
{ PC[p] := L7; write(p, Want[p], False) }

transition t2_L7_L8_load_Turn (p)
requires { p = #2 && PC[p] = L7 }
{ PC[p] := L8; TurnL[p] := read(p, Turn) }

transition t2_L8_L7_Turn_Other (p)
requires { p = #2 && PC[p] = L8 && TurnL[p] <> 1 }
{ PC[p] := L7 }

transition t2_L8_L9_Turn_Self (p)
requires { p = #2 && PC[p] = L8 && TurnL[p] = 1 }
{ PC[p] := L9 }

transition t2_L9_L2_store_Want2_True (p)
requires { p = #2 && PC[p] = L9 }
{ PC[p] := L2; write(p, Want[p], True) }

(* Critical section *)

transition t2_L10_L11_store_Turn_Other (p)
requires { p = #2 && PC[p] = L10 }
{ PC[p] := L11; write(p, Turn, 0) }

transition t2_L11_L1_store_Want2_False (p)
requires { p = #2 && PC[p] = L11 }
{ PC[p] := L1; write(p, Want[p], False) }
