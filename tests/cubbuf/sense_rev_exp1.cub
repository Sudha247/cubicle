
(*
E0 : X := T ; L0 || E0 : Y := T ; L0
L0 : Y = T -> E1 || L0 : X = T -> E1
E1 : X := F ; L1 || E1 : Y := F ; L1
L1 : Y = F -> E0 || L1 : X = F -> E0
*)

type loc = E0 | E1 | L0 | L1

type kind = KP1 | KP2 (*| KP3 | KP4*) | KBuf

type vars = VNone | VX | VY

var X : bool
var Y : bool
array PC[proc] : loc

array Kind[proc] : kind

array Var[proc,proc] : vars
array Val[proc,proc] : bool

init (p i) { PC[p] = E0 && PC[i] = E0 && X = False && Y = False &&
     	     Var[p,i] = VNone && Var[p,p] = VNone && Var[i,i] = VNone }

invariant (p1 p2) { Kind[p1] = KP1 && Kind[p2] = KP1 }
invariant (p1 p2) { Kind[p1] = KP2 && Kind[p2] = KP2 }

(* invariant (b1 b2) { Kind[b1] = KBuf && Kind[b2] = KBuf } *)
(* invariant (b1 b2 b3) { Kind[b1] = KBuf && Kind[b2] = KBuf && Kind[b3] = KBuf } *)
(* invariant (b1 b2 b3 b4) { Kind[b1] = KBuf && Kind[b2] = KBuf && Kind[b3] = KBuf && Kind[b4] = KBuf } *)

(* BS = 1 / W/O BRAB : 66 nodes *)

(* BS = 1 / BRAB 3 -> 98 nodes // When injected : BS = 1-n -> 8 nodes *)

(* Buffer structure *)
(* unsafe (p1) { PC[p1] = E1 && Kind[p1] = KBuf } (\* 1 *\) *)
(* unsafe (p1 p2) { Kind[p2] <> KBuf && Var[p1, p2] = VX } (\* 5 *\) *)
(* unsafe (p1 p2) { Kind[p2] <> KBuf && Var[p1, p2] = VY } (\* 4 *\) *)

(* Can't have X = True ^ Y = True ^ PC[p] = E0 *)
unsafe (p1) { X = True && Y = True && PC[p1] = E0 && Kind[p1] = KP1 } (* 3 *)
unsafe (p1) { X = True && Y = True && PC[p1] = E0 && Kind[p1] = KP2 } (* 2 *)

(* Can't have (X = False v Y = False) ^ PC[p1] = E1 ^ PC[p2] = E1 *)
(* unsafe (p1 p2) { X = False && PC[p1] = E1 && PC[p2] = E1 } (\* 12 *\) *)
(* unsafe (p1 p2) { Y = False && PC[p1] = E1 && PC[p2] = E1 } (\* 6 *\) *)

(* unsafe (p1 p2) { X = True && PC[p1] = E0 && Var[p1, p2] = VY } (\* 7 *\) *)
(* unsafe (p1 p2) { X = False && PC[p1] = E0 && Var[p1, p2] = VX } (\* 10 *\) *)
(* unsafe (p1 p2) { Y = True && PC[p1] = E0 && Var[p1, p2] = VX } (\* 13 *\) *)
(* unsafe (p1 p2) { Y = False && PC[p1] = E0 && Var[p1, p2] = VY } (\* 14 *\) *)
(* unsafe (p1 p2 p3) { X = True && PC[p3] = E0 && Var[p1, p2] = VX } (\* 27 *\) *)
(* unsafe (p1 p2 p3) { Y = True && PC[p1] = E0 && Var[p2, p3] = VY } (\* 22 *\) *)

(* unsafe (p1 p2) { X = True && PC[p1] = E1 && Var[p1, p2] = VX } (\* 19 *\) *)
(* unsafe (p1 p2) { X = False && PC[p1] = E1 && Var[p1, p2] = VY } (\* 16 *\) *)
(* unsafe (p1 p2) { Y = True && PC[p1] = E1 && Var[p1, p2] = VY } (\* 11 *\) *)
(* unsafe (p1 p2) { Y = False && PC[p1] = E1 && Var[p1, p2] = VX } (\* 8 *\) *)
(* unsafe (p1 p2 p3) { X = False && PC[p1] = E1 && Var[p2, p3] = VY } (\* 23 *\) *)

(* unsafe (p1 p2) { X = False && PC[p1] = L1 && Var[p1, p2] = VX } (\* 9 *\) *)
(* unsafe (p1 p2) { Y = False && PC[p1] = L1 && Var[p1, p2] = VY } (\* 15 *\) *)

(* unsafe (p1 p2) { X = True && Y = True && PC[p1] = L0 && Var[p1, p2] = VY } (\* 20 *\) *)
(* unsafe (p1 p2) { X = True && Y = True && PC[p1] = L0 && Var[p1, p2] = VX } (\* 21 *\) *)

(* unsafe (p1 p2) { X = False && Var[p1, p2] = VX && Val[p1, p2] = False } (\* 18 *\) *)
(* unsafe (p1 p2) { Y = False && Var[p1, p2] = VY && Val[p1, p2] = False } (\* 17 *\) *)

(* unsafe (p1 p2 p3) { X = True && Var[p1, p2] = VY && Var[p3, p2] = VY } (\* 24 *\) *)

(* unsafe (p1 p2 p3) { X = True && Kind[p1] = KP2 && Var[p3, p2] = VY } (\* 25 *\) *)
(* unsafe (p1 p2 p3) { Y = True && Kind[p3] = KP1 && Var[p1, p2] = VX } (\* 26 *\) *)


(* BS = 1 / BRAB 4 -> 65 nodes *)
(* When injected : BS = 1 -> 45 n / BS = 2 -> 152 n / BS = 3 -> 272 n / BS = N -> 320 n *)
(* invariant (p1) { PC[p1] = L0 && Kind[p1] = KBuf } (\* 1 *\) *)
(* invariant (p1) { PC[p1] = L1 && Kind[p1] = KBuf } (\* 2 *\) *)
(* invariant (p1 p2) { Kind[p2] <> KBuf && Var[p1, p2] = VX } (\* 3 *\) *)
(* invariant (p1 p2) { Kind[p2] <> KBuf && Var[p1, p2] = VY } (\* 4 *\) *)
(* invariant (p1 p2) { PC[p1] = E0 && Var[p1, p2] = VX && Val[p1, p2] = True } (\* 5 *\) *)
(* invariant (p1 p2) { PC[p1] = E1 && Var[p1, p2] = VY && Val[p1, p2] = False } (\* 6 *\) *)
(* invariant (p1 p2) { X = True && PC[p1] = L0 && Var[p1, p2] = VY && Val[p1, p2] = False } (\* 7 *\) *)
(* invariant (p1 p2) { Y = False && PC[p1] = L1 && Var[p1, p2] = VX && Val[p1, p2] = True } (\* 8 *\) *)
(* invariant (p1 p2) { X = True && PC[p1] = L1 && Var[p1, p2] = VX && Val[p1, p2] = True } (\* 9 *\) *)
(* invariant (p1 p2) { Y = False && PC[p1] = L0 && Var[p1, p2] = VY && Val[p1, p2] = False } (\* 10 *\) *)


(* BS = 2 / W/O BRAB : 237 nodes *)

(* BS = 2 / BRAB 3 -> too many restarts *)

(* BS = 2 / BRAB 4 -> 197 nodes *)
(* (1)  PC[#1] = L0 && Kind[#1] = KBuf *)
(* (2)  PC[#1] = L1 && Kind[#1] = KBuf *)
(* (3)  Kind[#2] <> KBuf && Var[#1, #2] = VX *)
(* (4)  Kind[#2] <> KBuf && Var[#1, #2] = VY *)
(* (5)  Kind[#1] = KP2 && Var[#1, #2] = VX *)
(* (6)  Kind[#1] = KP1 && Var[#1, #2] = VY *)
(* (7)  PC[#1] = E0 && Var[#1, #2] = VX && Val[#1, #2] = True *)
(* (8)  PC[#1] = E1 && Var[#1, #2] = VY && Val[#1, #2] = False *)
(* (9)  PC[#1] = E1 && Var[#1, #2] = VX && Val[#1, #2] = False *)
(* (10)  PC[#1] = E0 && Var[#1, #2] = VY && Val[#1, #2] = True *)
(* (11)  X = True && PC[#1] = L0 && Var[#1, #2] = VY && Val[#1, #2] = False *)
(* (12)  Y = False && PC[#1] = L1 && Var[#1, #2] = VX && Val[#1, #2] = True *)
(* (13)  Y = True && PC[#1] = L0 && Var[#1, #2] = VX && Val[#1, #2] = False *)
(* (14)  X = False && PC[#1] = L1 && Var[#1, #2] = VY && Val[#1, #2] = True *)
(* (15)  X = True && PC[#1] = L1 && Var[#1, #2] = VX && Val[#1, #2] = True *)
(* (16)  Y = False && PC[#1] = L0 && Var[#1, #2] = VY && Val[#1, #2] = False *)
(* (17)  Y = True && PC[#1] = L1 && Var[#1, #2] = VY && Val[#1, #2] = True *)
(* (18)  X = False && PC[#1] = L0 && Var[#1, #2] = VX && Val[#1, #2] = False *)
(* (19)  PC[#1] = E0 && Var[#1, #2] = VY && Var[#1, #3] = VY *)
(* (20)  PC[#1] = E1 && Var[#1, #2] = VX && Var[#1, #3] = VX *)
(* (21)  PC[#1] = E0 && Var[#1, #2] = VX && Var[#1, #3] = VX *)
(* (22)  PC[#1] = E1 && Var[#1, #2] = VY && Var[#1, #3] = VY *)
(* (23)  X = False && PC[#1] = E1 && Kind[#2] = KBuf && Var[#1, #3] = VY *)
(* (24)  Y = True && PC[#1] = E0 && Kind[#2] = KBuf && Var[#1, #3] = VX *)
(* (25)  X = True && PC[#1] = E0 && Kind[#2] = KBuf && Var[#1, #3] = VY *)
(* (26)  Y = False && PC[#1] = E0 && Kind[#3] = KBuf && Var[#1, #2] = VY *)
(* (27)  Y = False && PC[#1] = E1 && Kind[#3] = KBuf && Var[#1, #2] = VX *)
(* (28)  X = True && PC[#1] = E1 && Kind[#3] = KBuf && Var[#1, #2] = VX *)
(* (29)  X = False && PC[#1] = L1 && Var[#1, #2] = VY && Var[#1, #3] = VY *)
(* (30)  X = False && PC[#1] = E0 && Kind[#3] = KBuf && Var[#1, #2] = VX *)
(* (31)  Y = True && PC[#1] = E1 && Kind[#3] = KBuf && Var[#1, #2] = VY *)
(* (32)  Y = True && PC[#1] = L0 && Var[#1, #2] = VX && Var[#1, #3] = VX *)
(* (33)  Y = False && PC[#1] = L1 && Var[#1, #2] = VX && Var[#1, #3] = VX *)
(* (34)  X = True && PC[#1] = L0 && Var[#1, #2] = VY && Var[#1, #3] = VY *)
(* (35)  X = False && Y = False && PC[#1] = L1 && Kind[#3] = KBuf && Var[#1, #2] = VY *)
(* (36)  X = False && Y = False && PC[#1] = E1 && Kind[#2] = KBuf && Kind[#3] = KBuf *)
(* (37)  X = True && Y = True && PC[#1] = L0 && Kind[#3] = KBuf && Var[#1, #2] = VX *)
(* (38)  X = False && Y = False && PC[#1] = L1 && Kind[#3] = KBuf && Var[#1, #2] = VX *)
(* (39)  X = True && Y = True && PC[#1] = L0 && Kind[#3] = KBuf && Var[#1, #2] = VY *)
(* (40)  X = True && Y = True && PC[#1] = E0 && Kind[#2] = KBuf && Kind[#3] = KBuf *)
(* (41)  X = True && Y = True && Kind[#1] = KBuf && Var[#3, #2] = VY && Val[#3, #2] = True *)
(* (42)  X = False && Y = False && Kind[#1] = KBuf && Var[#3, #2] = VX && Val[#3, #2] = False *)
(* (43)  Var[#1, #3] = VX && Var[#1, #4] = VX && Var[#2, #3] = VY *)
(* (44)  Var[#1, #3] = VX && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (45)  PC[#1] = E0 && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (46)  PC[#2] = E1 && Var[#1, #3] = VX && Var[#1, #4] = VX *)
(* (47)  PC[#1] = E1 && Var[#1, #3] = VX && Var[#2, #4] = VY *)
(* (48)  PC[#2] = E0 && Var[#1, #4] = VX && Var[#2, #3] = VY *)
(* (49)  PC[#1] = E0 && Var[#1, #4] = VX && Var[#2, #3] = VY *)
(* (50)  PC[#2] = E0 && Var[#1, #3] = VX && Var[#1, #4] = VX *)
(* (51)  PC[#1] = E1 && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (52)  PC[#2] = E1 && Var[#1, #3] = VX && Var[#2, #4] = VY *)
(* (53)  Y = False && PC[#1] = L1 && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (54)  X = True && PC[#2] = L0 && Var[#1, #3] = VX && Var[#1, #4] = VX *)
(* (55)  Y = True && PC[#1] = L0 && Var[#1, #3] = VX && Var[#2, #4] = VY *)
(* (56)  X = False && PC[#2] = L1 && Var[#1, #4] = VX && Var[#2, #3] = VY *)
(* (57)  Y = False && PC[#1] = L1 && Var[#1, #4] = VX && Var[#2, #3] = VY *)
(* (58)  X = False && PC[#2] = L1 && Var[#1, #3] = VX && Var[#1, #4] = VX *)
(* (59)  Y = True && PC[#1] = L0 && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (60)  X = True && PC[#2] = L0 && Var[#1, #3] = VX && Var[#2, #4] = VY *)
(* (61)  Y = True && PC[#1] = E0 && Kind[#3] = KBuf && Var[#2, #4] = VY *)
(* (62)  Y = True && PC[#2] = E0 && Kind[#4] = KBuf && Var[#1, #3] = VX *)
(* (63)  X = False && PC[#1] = E1 && Kind[#4] = KBuf && Var[#2, #3] = VY *)
(* (64)  X = False && PC[#2] = E1 && Kind[#3] = KBuf && Var[#1, #4] = VX *)
(* (65)  Y = False && PC[#1] = E1 && Kind[#4] = KBuf && Var[#2, #3] = VY *)
(* (66)  X = True && PC[#2] = E0 && Kind[#4] = KBuf && Var[#1, #3] = VX *)
(* (67)  Y = True && PC[#2] = L1 && Var[#1, #3] = VX && Var[#1, #4] = VX *)
(* (68)  X = False && PC[#1] = L0 && Var[#2, #3] = VY && Var[#2, #4] = VY *)
(* (69)  X = True && PC[#1] = E0 && Kind[#3] = KBuf && Var[#4, #2] = VY *)
(* (70)  Y = True && Var[#1, #2] = VY && Var[#4, #3] = VX && Val[#4, #3] = True *)
(* (71)  X = False && Var[#1, #2] = VX && Var[#4, #3] = VY && Val[#4, #3] = False *)
(* (72)  X = True && Var[#1, #2] = VX && Var[#4, #3] = VY && Val[#4, #3] = True *)
(* (73)  Y = False && PC[#1] = E1 && Kind[#3] = KBuf && Var[#4, #2] = VX *)
(* (74)  Y = False && Var[#1, #2] = VY && Var[#4, #3] = VX && Val[#4, #3] = False *)
(* (75)  X = True && PC[#1] = L1 && Var[#4, #2] = VY && Var[#4, #3] = VY *)
(* (76)  Y = False && PC[#1] = L0 && Var[#4, #2] = VX && Var[#4, #3] = VX *)
(* (77)  X = False && Y = True && PC[#2] = L1 && Kind[#4] = KBuf && Var[#1, #3] = VX *)
(* (78)  X = True && Y = False && PC[#1] = L1 && Kind[#3] = KBuf && Var[#4, #2] = VY *)


(* BS = 3 / W/O BRAB : 429 nodes *)



unsafe (p1 p2) { Kind[p1] = KP1 && Kind[p2] = KP2 &&
       	         PC[p1] = E0 && PC[p2] = E1 }



transition t1_1 (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = E0 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = VNone)) }
{ PC[p] := L0; Var[p,i] := VX; Val[p,i] := True; }

transition t1_2a_mem (p)
requires { Kind[p] = KP1 &&
	   PC[p] = L0 && Y = True &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] <> VY)) }
{ PC[p] := E1; }

(*transition t1_2b_buf (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L0 && Var[p,i] = VY && Val[p,i] = True &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] <> VY)) }
{ PC[p] := E1; }*)

transition t1_3 (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = E1 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = VNone)) }
{ PC[p] := L1; Var[p,i] := VX; Val[p,i] := False; }

transition t1_4a_mem (p)
requires { Kind[p] = KP1 &&
	   PC[p] = L1 && Y = False &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] <> VY)) }
{ PC[p] := E0; }

(*transition t1_4b_buf (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L1 && Var[p,i] = VY && Val[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] <> VY)) }
{ PC[p] := E0; }*)



transition t2_1 (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = E0 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = VNone)) }
{ PC[p] := L0; Var[p,i] := VY; Val[p,i] := True; }

transition t2_2a_mem (p)
requires { Kind[p] = KP2 &&
	   PC[p] = L0 && X = True &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] <> VX)) }
{ PC[p] := E1; }

(*transition t2_2b_buf (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L0 && Var[p,i] = VX && Val[p,i] = True &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] <> VX)) }
{ PC[p] := E1; }*)

transition t2_3 (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = E1 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = VNone)) }
{ PC[p] := L1; Var[p,i] := VY; Val[p,i] := False; }

transition t2_4a_mem (p)
requires { Kind[p] = KP2 &&
	   PC[p] = L1 && X = False &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] <> VX)) }
{ PC[p] := E0; }

(*transition t2_4b_buf (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L1 && Var[p,i] = VX && Val[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] <> VX)) }
{ PC[p] := E0; }*)



transition flush_X (p i)
requires { Kind[p] = KP1 && Kind[p] <> KBuf && Kind[i] = KBuf && Var[p,i] = VX &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k < i) ||
	   		     (Kind[k] = KBuf && k > i && Var[p,k] = VNone)) }
{ X := Val[p,i]; Var[p,i] := VNone; }

transition flush_Y (p i)
requires { Kind[p] = KP2 && Kind[p] <> KBuf && Kind[i] = KBuf && Var[p,i] = VY &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k < i) ||
	   		     (Kind[k] = KBuf && k > i && Var[p,k] = VNone)) }
{ Y := Val[p,i]; Var[p,i] := VNone; }

