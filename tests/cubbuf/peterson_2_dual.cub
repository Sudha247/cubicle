
(* Peterson's mutual exclusion algorithm for 2 processes *)

type loc = L1 | L2 | L3 | L4 | CS | End
type kind = KProc | KBuf
type vars = VEmpty | VTurn | VWant

(* Program counters *)
array PC[proc] : loc

(* Process kinds *)
array Kind[proc] : kind

(* Dual-TSO Buffer *)
array Var[proc,proc] : vars
array Proc[proc,proc] : proc
array ValP[proc,proc] : proc
array ValB[proc,proc] : bool
array Own[proc,proc] : bool

(* Global variables *)
array Want[proc] : bool
var Turn : proc


init (p b) { PC[p] = L1 && Want[p] = False && Var[p,b] = VEmpty }

invariant (p1 p2 p3) { Kind[p1] = KProc && Kind[p2] = KProc && Kind[p3] = KProc}

unsafe (p1 p2) { Kind[p1] = KProc && Kind[p2] = KProc &&
                 PC[p1] = CS && PC[p2] = CS }



transition t_L1_L2_W_WantS_True (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = L1 &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L2; Want[p] := True;
  Var[p,b] := VWant; Proc[p,b] := p; ValB[p,b] := True; Own[p,b] := True }

transition t_L2_L3_W_Turn_Other (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
	   PC[p] = L2 &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L3; Turn := q;
  Var[p,b] := VTurn; ValP[p,b] := q; Own[p,b] := True }

transition t_L3_L4_Fence (p)
requires { Kind[p] = KProc &&
           PC[p] = L3 &&
	   forall_other b2. (Kind[b2] <> KBuf || Var[p,b2] = VEmpty) }
{ PC[p] := L4 }


transition t_L4_CS_R_WantO_False_rown (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&	   
	   Var[p,b] = VWant && Proc[p,b] = q &&
	   ValB[p,b] = False && Own[p,b] = True &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2
	       || Var[p,b2] <> VWant || Proc[p,b2] <> q || Own[p,b] = False) }
{ PC[p] := CS }

transition t_L4_CS_R_WantO_False_rbuf (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&	   
	   Var[p,b] = VWant && Proc[p,b] = q &&
	   ValB[p,b] = False && Own[p,b] = False &&
           forall_other b2. (Kind[b2] <> KBuf
	       || b2 < b && Var[p,b2] <> VWant
	       || b2 < b && Proc[p,b2] <> q
	       || b2 < b && Own[p,b2] = False
	       || b < b2 && Var[p,b2] = VEmpty) }
{ PC[p] := CS }


transition t_L4_CS_R_Turn_Self_rown (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&
	   Var[p,b] = VTurn && ValP[p,b] = p && Own[p,b] = True &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2
	       || Var[p,b2] <> VTurn || Own[p,b] = False) }
{ PC[p] := CS }

transition t_L4_CS_R_Turn_Self_rbuf (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&
	   Var[p,b] = VTurn && ValP[p,b] = p && Own[p,b] = False &&
           forall_other b2. (Kind[b2] <> KBuf
	       || b2 < b && Var[p,b2] <> VTurn
	       || b2 < b && Own[p,b2] = False
	       || b < b2 && Var[p,b2] = VEmpty) }
{ PC[p] := CS }



(* Critical section *)

transition t_CS_L1_W_WantS_False (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
	   PC[p] = CS &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L1; Want[p] := False;
  Var[p,b] := VWant; Proc[p,b] := p; ValB[p,b] := False; Own[p,b] := True }



(* Propagate transitions : propagate value from memory to read buffer (left) *)

transition t_propagate_turn (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VEmpty &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ Var[p,b] := VTurn; ValP[p,b] := Turn; Own[p,b] := False }

transition t_propagate_want_p (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VEmpty &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ Var[p,b] := VWant; Proc[p,b] := p; ValB[p,b] := Want[p]; Own[p,b] := False }

transition t_propagate_want_q (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VEmpty &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ Var[p,b] := VWant; Proc[p,b] := q; ValB[p,b] := Want[q]; Own[p,b] := False }



(* Delete transition : delete oldest read from buffer (right) *)
transition t_delete (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           Var[p,b] <> VEmpty &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b2 < b || Var[p,b2] = VEmpty) }
{ Var[p,b] := VEmpty }


