
(* Peterson's mutual exclusion algorithm for 2 processes *)

type loc = L1 | L2 | L3 | L4 | CS | End
type kind = KProc | KBuf
type vars = VEmpty | VTurn | VWant

(* Program counters *)
array PC[proc] : loc

(* Process kinds *)
array Kind[proc] : kind

(* Buffers *)
array Var[proc,proc] : vars
array Proc[proc,proc] : proc
array ValP[proc,proc] : proc
array ValB[proc,proc] : bool

(* Global variables *)
array Want[proc] : bool
var Turn : proc



init (p b) { PC[p] = L1 && Want[p] = False && Var[p,b] = VEmpty }

invariant (p1 p2 p3) { Kind[p1] = KProc && Kind[p2] = KProc && Kind[p3] = KProc}

unsafe (p1 p2) { Kind[p1] = KProc && Kind[p2] = KProc &&
                 PC[p1] = CS && PC[p2] = CS }

(* unsafe (p1 p2 p3 p4) { Kind[p1] = KProc && Kind[p2] = KProc && *)
(*                        Kind[p3] = KBuf && Kind[p4] = KBuf && *)
(*                        PC[p1] = CS && PC[p2] = CS } *)



transition t_L1_L2_W_WantS_True (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = L1 &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L2;
  Var[p,b] := VWant; Proc[p,b] := p; ValB[p,b] := True }


transition t_L2_L3_W_Turn_Other (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
	   PC[p] = L2 &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L3;
  Var[p,b] := VTurn; ValP[p,b] := q }


transition t_L3_L4_Fence (p)
requires { Kind[p] = KProc &&
           PC[p] = L3 &&
	   forall_other b. (Kind[b] <> KBuf || Var[p,b] = VEmpty) }
{ PC[p] := L4 }


transition t_L4_CS_R_WantO_False_rmem (p q)
requires { Kind[p] = KProc && Kind[q] = KProc &&
           PC[p] = L4 &&
	   Want[q] = False &&
           forall_other b. (Kind[b] <> KBuf ||
	                    Var[p,b] <> VWant || Proc[p,b] <> q) }
{ PC[p] := CS }

transition t_L4_CS_R_WantO_False_rbuf (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&	   
	   Var[p,b] = VWant && Proc[p,b] = q && ValB[p,b] = False &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 ||
	                     Var[p,b2] <> VWant || Proc[p,b2] <> q) }
{ PC[p] := CS }


transition t_L4_CS_R_Turn_Self_rmem (p)
requires { Kind[p] = KProc &&
           PC[p] = L4 &&
	   Turn = p &&
           forall_other b. (Kind[b] <> KBuf || Var[p,b] <> VTurn) }
{ PC[p] := CS }

transition t_L4_CS_R_Turn_Self_rbuf (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = L4 &&
	   Var[p,b] = VTurn && ValP[p,b] = p &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] <> VTurn) }
{ PC[p] := CS }


(* Critical section *)

transition t_CS_L1_W_WantS_False (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           PC[p] = CS &&
	   Var[p,b] = VEmpty &&
           forall_other b2. (Kind[b2] <> KBuf || b < b2 || Var[p,b2] = VEmpty) }
{ PC[p] := L1;
  Var[p,b] := VWant; Proc[p,b] := p; ValB[p,b] := False }



(* Flush transitions *)

transition t_flush_turn (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VTurn &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b2 < b || Var[p,b2] = VEmpty) }
{ Turn := ValP[p,b]; Var[p,b] := VEmpty }

transition t_flush_want_p (p b)
requires { Kind[p] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VWant && Proc[p,b] = p &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b2 < b || Var[p,b2] = VEmpty) }
{ Want[p] := ValB[p,b]; Var[p,b] := VEmpty }

transition t_flush_want_q (p q b)
requires { Kind[p] = KProc && Kind[q] = KProc && Kind[b] = KBuf &&
           Var[p,b] = VWant && Proc[p,b] = q &&
           forall_other b2. (
	       Kind[b2] <> KBuf || b2 < b || Var[p,b2] = VEmpty) }
{ Want[q] := ValB[p,b]; Var[p,b] := VEmpty }


