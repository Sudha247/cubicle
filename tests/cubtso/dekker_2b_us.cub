
(* Dekker's mutual exclusion algorithm for 2 processes *)

type loc = L1 | L2 | L3 | L4 | L5 | L6 | L7 | CS

(* Program counters *)
array PC[proc] : loc

(* Constants *)
const Active[proc] : bool

(* Global variables *)
weak array Want[proc] : bool
weak var Turn : proc


init (p) { PC[p] = L1 && Want[p] = False }

invariant (p1 p2 p3) {
  Active[p1] = True &&
  Active[p2] = True &&
  Active[p3] = True }

unsafe (p1 p2) { Active[p1] = True && PC[p1] = CS &&
                 Active[p2] = True && PC[p2] = CS }


transition t_L1_L2_W_WantS_True ([p])
requires { Active[p] = True && PC[p] = L1 }
{ PC[p] := L2; Want[p] := True }

transition t_L2_L3_R_WantO_True ([p] q)
requires { Active[p] = True && PC[p] = L2 &&
           Active[q] = True && Want[q] = True }
{ PC[p] := L3 }

transition t_L2_CS_R_WantO_False ([p] q)
requires { Active[p] = True && PC[p] = L2 &&
           Active[q] = True && Want[q] = False }
{ PC[p] := CS }

transition t_L3_L4_R_Turn_Other ([p])
requires { Active[p] = True && PC[p] = L3 && Turn <> p }
{ PC[p] := L4 }

transition t_L5_L2_R_Turn_Self ([p])
requires { Active[p] = True && PC[p] = L3 && Turn = p }
{ PC[p] := L2 }

transition t_L4_L5_W_WantS_False ([p])
requires { Active[p] = True && PC[p] = L4 }
{ PC[p] := L5; Want[p] := False }

transition t_L5_L5_R_Turn_Other ([p])
requires { Active[p] = True && PC[p] = L5 && Turn <> p }
{ PC[p] := L5 }

transition t_L5_L6_R_Turn_Self ([p])
requires { Active[p] = True && PC[p] = L5 && Turn = p }
{ PC[p] := L6 }

transition t_L6_L2_W_WantS_True ([p])
requires { Active[p] = True && PC[p] = L6 }
{ PC[p] := L2; Want[p] := True }

(* Critical section *)

transition t_CS_L7_W_Turn_Other ([p] q)
requires { Active[p] = True && PC[p] = CS &&
           Active[q] = True }
{ PC[p] := L7; Turn := q }

transition t_L7_L1_W_WantS_False ([p])
requires { Active[p] = True && PC[p] = L7 }
{ PC[p] := L1; Want[p] := False }
