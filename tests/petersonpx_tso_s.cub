
number_procs 2

type loc = L1 | L2 | L3 | L4 | End

(* Program counters *)
array PC[proc] : loc

(* Global variables *)
weak array Want[proc] : int
weak var Turn : int

init (p) { PC[p] = L1 && Want[p] = 0 && Turn = 0 }

(* Unsafe state reachable only in TSO *)
unsafe (p1 p2) { PC[p1] = L4 && PC[p2] = L4 }


(* Thread 1 *)

transition t1_L1_L2_store_Want_1 (p)
requires { p = #1 && PC[p] = L1 }
{ PC[p] := L2; write(p, Want[p], 1) }

transition t1_L2_L3_store_Turn (p)
requires { p = #1 && PC[p] = L2 }
{ PC[p] := L3; write(p, Turn, 2) }

transition t1_L3_L4_load_Want_2 (p)
fences (#1)
requires { p = #1 && PC[p] = L3 && read(p, Want[#2]) = 0 }
{ PC[p] := L4 }

transition t1_L3_L4_load_Turn (p)
fences (#1)
requires { p = #1 && PC[p] = L3 && read(p, Turn) = 1 }
{ PC[p] := L4 }

(* Critical section *)

transition t1_L4_End_store_Want_1 (p)
requires { p = #1 && PC[p] = L4 }
{ PC[p] := End; write(p, Want[p], 0) }


(* Thread 2 *)

transition t2_L1_L2_store_Want_2 (p)
requires { p = #2 && PC[p] = L1 }
{ PC[p] := L2; write(p, Want[p], 1) }

transition t2_L2_L3_store_Turn (p)
requires { p = #2 && PC[p] = L2 }
{ PC[p] := L3; write(p, Turn, 1) }

transition t2_L3_L4_load_Want_1 (p)
fences (#2)
requires { p = #2 && PC[p] = L3 && read(p, Want[#1]) = 0 }
{ PC[p] := L4 }

transition t2_L3_L4_load_Turn (p)
fences (#2)
requires { p = #2 && PC[p] = L3 && read(p, Turn) = 2 }
{ PC[p] := L4 }

(* Critical section *)

transition t2_L4_End_store_Want_2 (p)
requires { p = #2 && PC[p] = L4 }
{ PC[p] := End; write(p, Want[p], 0) }


