(*
   Generalization of Dekker mutual exclusion algorithm by Alain J. Martin from
   A new generalization of dekker’s algorithm for mutual
   exclusion. Inf. Process. Lett., 23(6) :295–297, Dec. 1986.

          --------------------------------------
          p(i) =
   NCS:       while true do
                  x(i) := true;
   LOOP:          while (exists j ≠ i. x(j)) do
   AWAIT:             x(i) := false;      
                      await [ t = 0 or t = i ];
   TURN:              t := i;
                      x(i) := true;
                  done;
   CS:            // CS(i);
                  x(i) := false;
                  t := 0;
              done
          --------------------------------------

   Translated from MCMT v2 model.
*)


type location = PRE | DONE | NCS | LOOP | AWAIT | TURN | TURN2 | CS | CS2

array P[proc] : location

weak array X[proc] : bool
weak var T : proc

var NullProc : proc
var NullProcInit : bool

init (i) { NullProcInit = False && X[i] = False && P[i] = PRE }

unsafe (i j) { P[i] = CS && P[j] = CS }
(* unsafe (i j k) { P[i] = CS && P[j] = CS && P[k] = CS } *)


transition pre_init (i)
requires { P[i] = PRE && NullProcInit = False }
{ P[i] := DONE; NullProcInit := True; NullProc := i; write(i, T, i) }

transition pre_start (i)
requires { P[i] = PRE && NullProcInit = True }
{ P[i] := NCS }


transition start (i)
requires { P[i] = NCS }
{
  P[i] := LOOP;
  write(i, X[i], True);
}


transition wait (i j)
requires { P[i] = LOOP && read(i, X[j]) = True }
{
  P[i] := AWAIT;
  write(i, X[i], False);
}


transition enter (i)
requires { P[i] = LOOP && forall_other j. read(i, X[j]) = False }
{
  P[i] := CS;
}


transition awaited_1 (i)
requires { P[i] = AWAIT && read(i, T) = NullProc }
{
  P[i] := TURN;
}

transition awaited_2 (i)
requires { P[i] = AWAIT && read(i, T) = i }
{
  P[i] := TURN;
}


transition turn_1 (i)
requires { P[i] = TURN }
{
  P[i] := TURN2;
  write(i, T, i);
}

transition turn_2 (i)
requires { P[i] = TURN2 }
{
  P[i] := LOOP;
  write(i, X[i], True);
}

transition loop_1 (i)
requires { P[i] = CS }
{
  P[i] := CS2;
  write(i, X[i], False);
}

transition loop (i)
requires { P[i] = CS2 }
{
  P[i] := NCS;
  write(i, T, NullProc);
}
