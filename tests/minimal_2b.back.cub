
type loc = L0 | L1 | L2 | L3

type kind = KP1 | KP2 | KP3 | KP4 | KP5 | KP6 | KP7 | KBuf

var F : bool
array PC[proc] : loc

array Kind[proc] : kind

array Var[proc,proc] : bool
array Val[proc,proc] : bool

init (p i) { PC[p] = L0 && PC[i] = L0 && F = False &&
     	     Var[p,i] = False && Var[p,p] = False && Var[i,i] = False }

(*invariant (p1 p2) { Kind[p1] = Kind[p2] &&
	      	    Kind[p1] <> KBuf && Kind[p2] <> KBuf }*)

invariant (p1 p2) { Kind[p1] = KP1 && Kind[p2] = KP1 }
invariant (p1 p2) { Kind[p1] = KP2 && Kind[p2] = KP2 }
invariant (p1 p2) { Kind[p1] = KP3 && Kind[p2] = KP3 }
invariant (p1 p2) { Kind[p1] = KP4 && Kind[p2] = KP4 }
invariant (p1 p2) { Kind[p1] = KP5 && Kind[p2] = KP5 }
invariant (p1 p2) { Kind[p1] = KP6 && Kind[p2] = KP6 }
invariant (p1 p2) { Kind[p1] = KP7 && Kind[p2] = KP7 }

(*
invariant (p1 p2) { PC[p1] = L1 && PC[p2] = L3 } (* found with Brab 2 *)
invariant (p1 p2) { PC[p1] = L3 && PC[p2] = L3 } (* found with Brab 3+ *)

invariant (p) { Kind[p] = KP1 && PC[p] = L1 && F = True }
invariant (p) { Kind[p] = KP1 && PC[p] = L3 && F = True }
invariant (p) { Kind[p] = KP2 && PC[p] = L1 && F = False }
invariant (p) { Kind[p] = KP2 && PC[p] = L3 && F = False }
*)


(*
invariant (p1 p2) { PC[p1] = L1 && PC[p2] = L3 } (* 6 *)
invariant (p1 p2) { PC[p1] = L3 && PC[p2] = L3 } (* 10 *)

invariant (p1 p2) { F = False && PC[p1] = L1 && Kind[p1] = KP2 } (* 3 *)
invariant (p1 p2) { F = False && PC[p1] = L3 && Kind[p1] = KP2 } (* 4 *)
invariant (p1 p2) { F = True && PC[p1] = L1 && Kind[p2] = KP2 } (* 11 *)
invariant (p1 p2) { F = True && PC[p2] = L3 && Kind[p1] = KP2 } (* 14 *)
invariant (p1 p2) { F = False && PC[p2] = L3 && Kind[p1] = KP1 } (* 13 *)
*)

(*
invariant (p1 p2) { PC[p1] = L1 && Var[p1, p2] = True } (* 5 *)
invariant (p1 p2) { PC[p1] = L3 && Var[p1, p2] = True } (* 8 *)

invariant (p1 p2 p3) { PC[p1] = L3 && Var[p2, p3] = True } (* 16 *)

invariant (p1 p2) { F = False && Kind[p1] = KP2 && Var[p1, p2] = True } (* 12 *)
invariant (p1 p2 p3) { F = True && Kind[p1] = KP2 && Var[p2, p3] = True } (* 18 *)

invariant (p1 p2) { F = False && Var[p2, p1] = True && Val[p2, p1] = False } (* 15 *)
*)

(*
invariant (p1) { PC[p1] = L1 && Kind[p1] = KBuf } (* 1 *)
invariant (p1) { PC[p1] = L3 && Kind[p1] = KBuf } (* 2 *)

invariant (p1 p2) { Kind[p2] <> KBuf && Var[p1, p2] = True } (* 7 *)
invariant (p1 p2) { Kind[p1] = KBuf && Var[p1, p2] = True } (* 9 *)

invariant (p1 p2 p3) { Var[p1, p2] = True && Var[p1, p3] = True } (* 17 *)
*)


unsafe (p1 p2) { Kind[p1] = KP1 && Kind[p2] = KP2 &&
       	       	 PC[p1] = L1 && PC[p2] = L1 }



transition t1_1a_mem (p)
requires { Kind[p] = KP1 &&
	   PC[p] = L0 && F = False &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] = False)) }
{ PC[p] := L1; }

(*transition t1_1b_buf (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L0 && Var[p,i] = True && Val[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L1; }*)

transition t1_2 (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L1 && Var[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L2; Var[p,i] := True; Val[p,i] := True; }

transition t1_3a_mem (p)
requires { Kind[p] = KP1 &&
	   PC[p] = L2 && F = False &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] = False)) }
{ PC[p] := L3; }

(*transition t1_3b_buf (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L2 && Var[p,i] = True && Val[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L3; }*)

transition t1_4 (p i)
requires { Kind[p] = KP1 && Kind[i] = KBuf &&
	   PC[p] = L3 && Var[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L0; Var[p,i] := True; Val[p,i] := True; }



transition t2_1a_mem (p)
requires { Kind[p] = KP2 &&
	   PC[p] = L0 && F = True &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] = False)) }
{ PC[p] := L1; }

(*transition t2_1b_buf (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L0 && Var[p,i] = True && Val[p,i] = True &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L1; }*)

transition t2_2 (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L1 && Var[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L2; Var[p,i] := True; Val[p,i] := False; }

transition t2_3a_mem (p)
requires { Kind[p] = KP2 &&
	   PC[p] = L2 && F = True &&
	   forall_other k. (Kind[k] <> KBuf ||
	   		     (Kind[k] = KBuf && Var[p,k] = False)) }
{ PC[p] := L3; }

(*transition t2_3b_buf (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L2 && Var[p,i] = True && Val[p,i] = True &&
	   forall_other k. (Kind[k] <> KBuf || k > i ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L3; }*)

transition t2_4 (p i)
requires { Kind[p] = KP2 && Kind[i] = KBuf &&
	   PC[p] = L3 && Var[p,i] = False &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k > i) ||
	   		     (Kind[k] = KBuf && k < i && Var[p,k] = False)) }
{ PC[p] := L0; Var[p,i] := True; Val[p,i] := False; }



transition flush_F (p i)
requires { Kind[p] <> KBuf && Kind[i] = KBuf && Var[p,i] = True &&
	   forall_other k. (Kind[k] <> KBuf || (Kind[k] = KBuf && k < i) ||
	   		     (Kind[k] = KBuf && k > i && Var[p,k] = False)) }
{ F := Val[p,i]; Var[p,i] := False; }
