
type location = Q1 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7

type vars = VNone | VF
type kind = KProc | KBuf

array A[proc] : location
array F[proc] : bool

array Kind[proc] : kind
array Var[proc,proc] : vars
array Par[proc,proc] : proc
array Val[proc,proc] : bool

init (p) { A[p] = Q1 && F[p] = False }

(* Maximum 2 procs *)
invariant (p1 p2 p3) { Kind[p1] = KProc &&
	      	       Kind[p2] = KProc &&
		       Kind[p3] = KProc }

(* Maximum 2 cases de buffer (quelque soit le proc) *)
invariant (p1 p2 p3) { Kind[p1] = KBuf &&
	      	       Kind[p2] = KBuf &&
	      	       Kind[p3] = KBuf }

unsafe (p1 p2 p3 p4) { Kind[p1] = KProc && Kind[p2] = KProc &&
       	      	       Kind[p3] = KBuf && Kind[p4] = KBuf &&
            	       A[p1] = Q6 && A[p2] = Q6 }

transition t1 (p i)
requires { Kind[p] = KProc && Kind[i] = KBuf &&
	   A[p] = Q1 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] = KProc || (Kind[k] = KBuf && k > i) ||
	   	 	     (k < i && Kind[k] = KBuf && Var[p, k] = VNone)) }
{ A[p] := Q2; Var[p,i] := VF; Par[p, i] := p; Val[p,i] := False }

transition t2 (p1 p2)
requires { Kind[p1] = KProc && Kind[p2] = KProc &&
	   A[p1] = Q2 && p2 < p1 && F[p2] = True }
{ A[p1] := Q1; }

transition t3 (p)
requires { Kind[p] = KProc &&
	   A[p] = Q2 && forall_other p2. (
	     Kind[p2] = KBuf ||
	     (Kind[p2] = KProc && p <= p2) ||
	     (Kind[p2] = KProc && F[p2] = False)) }
{ A[p] := Q3; }

transition t4 (p i)
requires { Kind[p] = KProc && Kind[i] = KBuf &&
	   A[p] = Q3 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] = KProc || (Kind[k] = KBuf && k > i) ||
	   	 	     (k < i && Kind[k] = KBuf && Var[p, k] = VNone)) }
{ A[p] := Q4; Var[p,i] := VF; Par[p, i] := p; Val[p,i] := True }

transition t5 (p1 p2)
requires { Kind[p1] = KProc && Kind[p2] = KProc &&
	   A[p1] = Q4 && p2 < p1 && F[p2] = True }
{ A[p1] := Q1; }

transition t6 (p)
(* fences (p) *)
requires { Kind[p] = KProc &&
	   A[p] = Q4 && forall_other p2. (
	     (Kind[p2] = KBuf && Var[p, p2] = VNone) ||
	     (Kind[p2] = KProc && p <= p2) ||
	     (Kind[p2] = KProc && F[p2] = False)) }
{ A[p] := Q5; }

transition t7 (p)
requires { Kind[p] = KProc &&
	   A[p] = Q5 && forall_other p2. (
	     Kind[p2] = KBuf ||
	     (Kind[p2] = KProc && p2 <= p) ||
	     (Kind[p2] = KProc && F[p2] = False)) }
{ A[p] := Q6; }

transition t8 (p i)
requires { Kind[p] = KProc && Kind[i] = KBuf &&
	   A[p] = Q6 && Var[p,i] = VNone &&
	   forall_other k. (Kind[k] = KProc || (Kind[k] = KBuf && k > i) ||
	   	 	     (k < i && Kind[k] = KBuf && Var[p, k] = VNone)) }
{ A[p] := Q1; Var[p,i] := VF; Par[p, i] := p; Val[p,i] := False }

(*transition t9 (x)
requires { A[x] = Q7 }
{ A[x] := Q1; }*)


(* Gestion des buffers *)

(* Ecritures par p sur F[p] *)
transition flush_F_self (p i)
requires { Kind[p] = KProc && Kind[i] = KBuf &&
	   Var[p,i] = VF && Par[p,i] = p &&
	   forall_other k. (Kind[k] = KProc || k < i ||
	                     (i < k && Kind[k] = KBuf && Var[p,k] = VNone)) }
{ F[p] := Val[p,i];
  Var[p,i] := VNone; }

(* Ecritures par p sur F[p2] avec p <> p2 *)
(* Inutile : un processus p n'Ã©crit que dans F[p] *)
(* Si on active cette transition, on peut attendre longtemps... *)
(*transition flush_F_other (p i p2)
requires { Kind[p] = KProc && Kind[p2] = KProc && Kind[i] = KBuf &&
	   Var[p,i] = VF && Par[p,i] = p2 &&
	   forall_other k. (Kind[k] = KProc || k < i ||
	   		     (i < k && Kind[k] = KBuf && Var[p,k] = VNone)) }
{ F[p2] := Val[p,i];
  Var[p,i] := VNone; }*)
