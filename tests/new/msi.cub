
number_procs 3

(*
  2 procs : 33 nodes, 365 FP, 592 SC, 22s
  3 procs : TO

New version (better read/write assoc) :
  2 procs : 16 nodes, 77 FP, 264 SC, 2,6s, H = 3
  3 procs : 259 nodes, 3490 FP, 12675 SC, 38m10, H = 7

New version 2 (inline co, prop) :
  2 procs : 33 nodes, 336 FP, 542 SC, 6s, H = ?
  3 procs : 431 nodes, 16394 FP, 27573 SC, 35m04, H = ?

New version 3 (inline fr) :
  2 procs : 14 nodes, 70 FP, 135 SC, 1s, H = ?
  3 procs : 124 nodes, 1960 FP, 3561 SC, 2m08, H = ?

New version 4 (fix "bug" in prop/sync) :
  2 procs : 14 nodes, 66 FP, 129 SC, 1s, H = ?
  3 procs : 111 nodes, 1636 FP, 2986 SC, 1m45, H = ?
  4 procs : TO / 470 N, 6394 FP, 11590 SC, 74m (60m FP, 16m psubst, 13m solv, 2m safety, 8m acyc, 8m esubst, 7m mk_prop)
*)

type st = M | S | I

weak array Cache[proc] : st

init (i) { Cache[i] = I }

unsafe (i j k) { read(i, Cache[i]) = M && read(j, Cache[j]) <> I }
(* unsafe (i j) { read(j, Cache[j]) = M && read(j, Cache[j]) <> I } *)

(* unsafe (i j) { read(i, Cache[i]) = M && read(i, Cache[j]) <> I } *)
(* unsafe (i j) { read(i, Cache[j]) = M && read(j, Cache[i]) <> I } *)

transition read_miss (i)
requires { read(i, Cache[i]) = I }
{ write(i, Cache[j], case
       	   | j = i : S
       	   | read(i, Cache[j]) = M  : S) }

transition write_miss (i)
requires { read(i, Cache[i]) <> M }
{ write(i, Cache[j], case
       	   | j = i : M
	   | _ : I ) }
