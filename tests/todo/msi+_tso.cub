
(* number_procs 6 *)
(*
  2 procs : 3 N / 1 FP / 8 SC / 0.1s
  3 procs : 19 N / 42 FP / 104 SC / 9s
  4 procs : 43 N / 222 FP / 474 SC / 1m00
  5 procs : 58 N / 375 FP / 772 SC / 6m32
  6 procs : 58 N / 390 FP / 787 SC / 7m41
  N procs : 58 N / 390 FP / 787 SC / 7m17
*)

type state = M | S | I

weak array Cache[proc]: state
weak array Shr[proc] : bool
weak var Current : proc
weak var Extgnd : bool

init (i) { Cache[i] = I && Shr[i] = False && Extgnd = False}

unsafe (i j) { i @ Cache[i] = M && j @ Cache[j] = M }
(*unsafe (i j) { read(j, Cache[j]) = M && read(j, Cache[j]) = M }
unsafe (i j) { read(i, Cache[j]) = M && read(j, Cache[j]) = M }
unsafe (i j) { read(j, Cache[i]) = M && read(j, Cache[j]) = M }
unsafe (i j) { read(j, Cache[j]) = M && read(i, Cache[j]) = M }
unsafe (i j) { read(j, Cache[j]) = M && read(j, Cache[i]) = M }
unsafe (i j) { read(i, Cache[j]) = M && read(i, Cache[j]) = M }
unsafe (i j) { read(i, Cache[j]) = M && read(j, Cache[i]) = M }*)

transition read_miss_1 ([i] j)
requires { Cache[i] = I && Current = j && Extgnd = True }
{
  Shr[i] := True;
  Cache[k] := case 
              | k = i : S
              | k = j : S
	      | _ : Cache[k];
  Extgnd := False }

transition read_miss_2 ([i])
requires { Cache[i] = I && Extgnd = False }
{ Shr[i] := True; Cache[i] := S }

transition write_miss ([i])
requires { Cache[i] <> M }
{ Shr[k] := case 
  	    | k = i : True
            | Shr[k] = True : False
	    | _ : Shr[k];
  Cache[k] := case
	      | k = i : M
 	      | Shr[k] = True : I
	      | _ : Cache[k];
  Current := i;
  Extgnd := True }
