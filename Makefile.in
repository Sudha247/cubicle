##########################################################################
#                                                                        #
#                                  Cubicle                               #
#             Combining model checking algorithms and SMT solvers        #
#                                                                        #
#                  Sylvain Conchon and Alain Mebsout                     #
#                  Universite Paris-Sud 11                               #
#                                                                        #
#  Copyright 2011. This file is distributed under the terms of the       #
#  Apache Software License version 2.0                                   #
#                                                                        #
##########################################################################

QUIET=""

# where to install the binaries
DESTDIR=
prefix=@prefix@
exec_prefix=@exec_prefix@
BINDIR=$(DESTDIR)@bindir@
LIBDIR=$(DESTDIR)@libdir@/cubicle

# where to install the man page
MANDIR=$(DESTDIR)@mandir@

# other variables set by ./configure
OCAMLC   = @OCAMLC@
OCAMLOPT = @OCAMLOPT@
OCAMLDEP = @OCAMLDEP@
OCAMLLEX = @OCAMLLEX@
OCAMLYACC= @OCAMLYACC@
OCAMLLIB = @OCAMLLIB@
FUNCTORYLIB = @FUNCTORYLIB@
OCAMLBEST= @OCAMLBEST@
OCAMLVERSION = @OCAMLVERSION@
OCAMLWIN32 = @OCAMLWIN32@
EXE = @EXE@

INCLUDES = $(FUNCTORYLIB) -thread -I common/ -I smt/

BFLAGS = -dtypes -g $(INCLUDES) -annot
OFLAGS = -dtypes $(INCLUDES) -annot

BIBBYTE=nums.cma unix.cma

BIBOPT=$(BIBBYTE:.cma=.cmxa)

# main target
#############

NAME = cubicle
BYTE=$(NAME).byte
OPT=$(NAME).opt

all: make_functory $(OCAMLBEST) 

# configuration of the fake functory library
############################################


make_functory:
	@if [ -z "$(FUNCTORYLIB)" ]; then \
	cp -f fake_functory.mli functory.mli;\
	cp -f fake_functory.ml functory.ml;\
	$(OCAMLC) -c functory.mli;\
	$(OCAMLOPT) -c functory.ml;\
	$(OCAMLOPT) -o functory.cmxa -a functory.cmx functory.o;\
	fi

# bytecode and native-code compilation
######################################

SMTCMO = smt/exception.cmo smt/symbols.cmo \
	 smt/ty.cmo smt/term.cmo smt/literal.cmo \
         smt/solver_types.cmo smt/explanation.cmo \
         smt/polynome.cmo smt/uf.cmo smt/use.cmo \
	 smt/intervals.cmo smt/fm.cmo smt/arith.cmo smt/sum.cmo \
         smt/combine.cmo smt/cc.cmo smt/solver.cmo smt/smt.cmo

COMMONCMO = common/timer.cmo common/hashcons.cmo common/hstring.cmo\
	    common/vec.cmo common/heap.cmo common/iheap.cmo

CMO = $(COMMONCMO) $(SMTCMO) \
      version.cmo options.cmo ast.cmo parser.cmo lexer.cmo pretty.cmo \
      prover.cmo search.cmo bwreach.cmo typing.cmo main.cmo

CMX = $(CMO:.cmo=.cmx)

MAINCMO = $(CMO) main.cmo
MAINCMX = $(MAINCMO:.cmo=.cmx)

RUNCMO = $(CMO) run.cmo
RUNCMX = $(RUNCMO:.cmo=.cmx)

GENERATED = version.ml parser.ml parser.mli lexer.ml

byte: $(NAME).byte
opt: $(NAME).opt

$(NAME).byte: $(MAINCMO)
	$(if $(QUIET),@echo 'Linking $@' &&) \
	$(OCAMLC) $(BFLAGS) -o $@ $(BIBBYTE) functory.cma threads.cma $^

$(NAME).opt: $(MAINCMX)
	$(if $(QUIET),@echo 'Linking $@' &&) \
	$(OCAMLOPT) $(OFLAGS) -o $@ $(BIBOPT) functory.cmxa threads.cmxa $^

VERSION=0.2

version.ml: config.status
	@echo "let version = \""$(VERSION)"\"" > version.ml
	@echo "let date = \""`date`"\"" >> version.ml
	@echo "let libdir = \""$(LIBDIR)"\"" >> version.ml



# generic rules
###############

.SUFFIXES: .mli .ml .cmi .cmo .cmx .mll .mly

.mli.cmi:
	@true compile -w a $(BFLAGS) $< 
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLC) -c $(BFLAGS) $<

.ml.cmo:
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLC) -c $(BFLAGS) $<
	@true compile -w a $(BFLAGS) $< 

.ml.o:
	@true compile -w a $(BFLAGS) $< 
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLOPT) -c $(OFLAGS) $<

.ml.cmx:
	$(if $(QUIET),@echo 'Compiling $@' &&) $(OCAMLOPT) -c $(OFLAGS) $<
	@true compile -w a $(BFLAGS) $< 

.mll.ml:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLLEX) $< > /dev/null

.mly.ml:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLYACC) -v $< 

.mly.mli:
	$(if $(QUIET),@echo 'Compiling $<' &&) $(OCAMLYACC) -v $< 


# file headers
##############
headers:
	headache -c doc/headache_config.txt -h doc/cubicle_header.txt \
		Makefile.in configure.in *.ml *.ml[ily] \
		common/*.ml common/*.mli smt/*.ml smt/*.mli

# Emacs tags
############

tags:
	find . -name "*.ml*" | sort -r | xargs \
	etags "--regex=/let[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/let[ \t]+rec[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/and[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/type[ \t]+\([^ \t]+\)/\1/" \
              "--regex=/exception[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/val[ \t]+\([^ \t]+\)/\1/" \
	      "--regex=/module[ \t]+\([^ \t]+\)/\1/"

# installation
##############

install: install-man
	mkdir -p $(BINDIR)
	cp -f $(NAME).$(OCAMLBEST) $(BINDIR)/$(NAME)$(EXE)

install-byte: install-man
	mkdir -p $(BINDIR)
	cp -f $(NAME).byte $(BINDIR)/$(NAME)$(EXE)

install-opt: install-man
	mkdir -p $(BINDIR)
	cp -f $(NAME).opt $(BINDIR)/$(NAME)$(EXE)

install-man:
	mkdir -p $(MANDIR)/man1
	cp -f doc/*.1 $(MANDIR)/man1




# clean
#######

clean:: 
	@rm -f *.cm[iox] *.o *~ *.annot
	@rm -f common/*.cm[iox] common/*.o common/*~ common/*.annot
	@rm -f smt/*.cm[iox] smt/*.o smt/*~ smt/*.annot
	@rm -f $(GENERATED) *.output
	@rm -f $(NAME).byte $(NAME).opt
	@rm -f functory.*

# depend
########

.depend depend:: $(GENERATED)
	@rm -f .depend
	@$(OCAMLDEP) -slash -I common/ common/*.ml common/*.mli > .depend
	@$(OCAMLDEP) -I common/ -I smt/ smt/*.ml smt/*.mli >> .depend
	@$(OCAMLDEP) -I common/ -I smt/ -slash *.ml *.mli >> .depend


include .depend


# export
########

DATE=$(shell date +%d/%m/%Y)

EXPORTDIR=$(NAME)-$(VERSION)
TAR=$(EXPORTDIR).tar

WEB = $$HOME/WWW/cubicle/

SMTFILES = smt/arith.ml smt/arith.mli smt/cc.ml smt/cc.mli smt/combine.ml\
	   smt/combine.mli smt/exception.ml smt/exception.mli\
	   smt/explanation.ml smt/explanation.mli smt/fm.ml smt/fm.mli\
	   smt/intervals.ml smt/intervals.mli smt/literal.ml\
	   smt/literal.mli smt/polynome.ml smt/polynome.mli smt/sig.mli\
	   smt/smt.ml smt/smt.mli smt/solver.ml smt/solver.mli\
	   smt/solver_types.ml smt/solver_types.mli smt/sum.ml smt/sum.mli\
	   smt/symbols.ml smt/symbols.mli smt/term.ml smt/term.mli\
	   smt/ty.ml smt/ty.mli smt/uf.ml smt/uf.mli smt/use.ml smt/use.mli

COMMONFILES = common/hashcons.ml common/hashcons.mli common/heap.ml\
	      common/heap.mli common/hstring.ml common/hstring.mli\
	      common/iheap.ml common/iheap.mli common/timer.ml\
	      common/timer.mli common/vec.ml common/vec.mli

FILES = ast.ml ast.mli bwreach.ml bwreach.mli fake_functory.ml\
	fake_functory.mli lexer.mll main.ml options.ml options.mli\
	parser.mly pretty.ml pretty.mli prover.ml prover.mli search.ml\
	search.mli test.ml typing.ml typing.mli version.ml

OTHERFILES = configure Makefile.in README COPYING

export:
	mkdir -p export
	mkdir -p export/$(EXPORTDIR)
	mkdir -p export/$(EXPORTDIR)/smt
	mkdir -p export/$(EXPORTDIR)/common
	mkdir -p export/$(EXPORTDIR)/examples
	cp $(SMTFILES) export/$(EXPORTDIR)/smt
	cp $(COMMONFILES) export/$(EXPORTDIR)/common
	cp $(FILES) export/$(EXPORTDIR)/
	cp $(OTHERFILES) export/$(EXPORTDIR)/
	cp examples/*.cub export/$(EXPORTDIR)/examples/
	cd export ; tar cf $(TAR) $(EXPORTDIR) ; gzip -f --best $(TAR)

release: export
	mkdir -p export/release
	cp export/$(TAR).gz export/release/
	cp doc/website/* export/release/
	cd export/release/; sed "s@#version#@$(VERSION)@g" index.html > index.html.tmp; sed  "s@#date#@$(DATE)@g" index.html.tmp > index.html; rm -f index.html.tmp
	cp -f export/release/* $(WEB)