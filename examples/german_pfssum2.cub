(*
 :comment      SOURCE: pfs distribution
 :comment      (difficult version)

 :smt (define-type locations (subrange 1 3))
 :smt (define-type messages1  (subrange 5 7))
 :smt (define-type messages2  (subrange 7 10))
 :comment   values 5, 11 for t[x] are mapped to false and  true, resp.
 :comment   value 5 for d[x] is mapped to  7
*)

type state = Invalid | Shared | Exclusive
(*
	 Invalid -> 1
	 Shared -> 2
	 Exclusive -> 3
*)

type msg1 = Empty1 | Reqs | Reqe 
(*
	Empty1 -> 5
	Reqs -> 6
	Reqe -> 7

*)

type msg2 = Empty2 | Inv | Gnts | Gnte
(*
	Empty2 -> 7
	Gnts -> 8
	Gnte -> 9
	Inv -> 10

*)

type msg3 = Empty3 | Invack
(*
	Empty3 -> true
	Invack -> false
*)


(*
:local a locations
:local u messages1
:local d messages2
:local t bool
:local c bool
:local s bool
:local l bool
:global g bool
:global m messages1
:global f bool

*)


globals = G[bool] M[msg1] F[bool]

arrays = A[proc,state] U[proc,msg1] D[proc,msg2] T[proc,msg3] 
         C[proc,bool] S[proc,bool] L[proc,bool]


init (z) {
     A[z] = Invalid && U[z] = Empty1 && D[z] = Empty2 &&
     T[z] = Empty3 && C[z] = False && S[z] = False && L[z] = False &&
     G = False && M = Empty1 && F = False }


unsafe (z1 z2) { A[z1] = Exclusive && A[z2] = Shared }

(*:comment h0    t1*)
transition t1(x)
require { M = Reqs && G = False && D[x] = Empty2 && C[x] = True && F = False }
assign { M := Empty1 }
D[j] := {| j = x : Gnts | _ : D[j] }
S[j] := {| j = x : True | _ : S[j] }


(*:comment h1    t2*)
transition t2(x)
require { S[x] = False && M = Reqe && D[x] = Empty2 && C[x] = True && F = False }
uguard (j) {S[j] = False}
assign { M := Empty1 ; G := True }
D[j] := {| j = x : Gnte | _ : D[j] }
S[j] := {| j = x : True | _ : S[j] }


(*:comment h2  t3*)
transition t3(x)
require { M = Empty1 && U[x] <> Empty1 && F = False }
assign { F := True ; L := S ; M := U[x] }
U[j] := {| j = x : Empty1 | _ : U[j] }
C[j] := {| j = x : True | _ : False }


(*:comment n1   t4*)
transition t4(x)
require { F = True && S[x] = False }
L[j] := {| j = x : False | _ : L[j] }


(*:comment n2   t5*)
transition t5(x)
require { F = True && S[x] = True }
L[j] := {| j = x : True | _ : L[j] }


(*:comment n3   t6*)
transition t6(x)
require { F = True && L[x] = S[x] } 
uguard (j) { L[j] = S[j] }
assign { F := False }


(*:comment h3    t7*)
transition t7(x)
require { M = Reqs && G = True && L[x] = True && D[x] = Empty2 && F = False }
D[j] := {| j = x : Inv | _ : D[j] }
L[j] := {| j = x : False | _ : L[j] }


(*:comment h4    t8*)
transition t8(x)
require { M = Reqe && L[x] = True && D[x] = Empty2 && F = False }
D[j] := {| j = x : Inv | _ : D[j] }
L[j] := {| j = x : False | _ : L[j] }


(*:comment h5   t9*)
transition t9(x)
require { M <> Empty1 && T[x] = Invack && F = False }
assign { G := False }
T[j] := {| j = x : Empty3 | _ : T[j] }
S[j] := {| j = x : False | _ : S[j] }



(*:comment c1    t10*)
transition t10(x)
require { A[x] = Invalid && U[x] = Empty1 && F = False }
A[j] := {| j = x : Invalid | _ : A[j] }
U[j] := {| j = x : Reqs | _ : U[j] }


(*:comment c2 - c3     t11*)
transition t11(x)
require { A[x] <> Exclusive && U[x] = Empty1 && F = False }
U[j] := {| j = x : Reqe | _ : U[j] }



(*:comment c4         t12*)
transition t12(x)
require { D[x] = Inv && T[x] = Empty3 && F = False }
A[j] := {| j = x : Invalid | _ : A[j] }
D[j] := {| j = x : Empty2 | _ : D[j] }
T[j] := {| j = x : Invack | _ : T[j] }


(*:comment c5   t13*)
transition t13(x)
require { D[x] = Gnts && F = False }
A[j] := {| j = x : Shared | _ : A[j] }
D[j] := {| j = x : Empty2 | _ : D[j] }


(*:comment c6    t14*)
transition t14(x)
require { D[x] = Gnte && F = False }
A[j] := {| j = x : Exclusive | _ : A[j] }
D[j] := {| j = x : Empty2 | _ : D[j] }


