module Germanish

use import array.Array
use import int.Int
use import ref.Refint
use import random.Random

scope import Msg

  type msg = Empty | Reqs | Reqe

  let (=) (a b: msg): bool
    ensures { result <-> a = b }
  = match a, b with
    | Empty, Empty | Reqs, Reqs | Reqe, Reqe -> true
    | _ -> false end

end

scope import State

  type state = Invalid | Shared | Exclusive

  let (=) (a b: state): bool
    ensures { result <-> a = b }
  = match a, b with
    | Invalid, Invalid | Shared, Shared | Exclusive, Exclusive -> true
    | _ -> false end

end

val coin () : bool

type proc = int

let forall_other_gnt_exclusive (arr : array bool) (p : proc)
    requires { p < arr.length }
    ensures {result = True <-> forall p':proc.
    	     0 <= p' < arr.length /\ p' <> p -> not arr[p']}
=
     let res = ref true in
     for i = 0 to arr.length - 1 do
         invariant {!res = True <-> forall p':proc.
	 	    0 <= p' < i /\ p' <> p -> not arr[p']}
         if arr[i] && i <> p then res := false
     done;
     !res

type system = {
  mutable exgntd : bool;
  mutable curcmd : msg;
  mutable curptr : proc;
  cache : array state;
  shrset : array bool;
}

let germanish (n:int) : system
    diverges
    requires {0 < n}
    ensures {forall i j : int. 0 <= i < n /\ 0 <= j < n /\
                    result.cache[i] = Exclusive /\ result.cache[j] <> Invalid
                    -> i = j}
=

    let s =  {
      exgntd = false;
      curcmd = Empty;
      curptr = Random.random_int n;

      cache = Array.make n Invalid;
      shrset = Array.make n false;
    } in

    while true do
        (* invariant {forall i: int. 0 <= i < n /\ s.cache[i] = Exclusive -> s.curptr = i} *)
        invariant {forall i j : int. 0 <= i < n /\ 0 <= j < n /\ s.cache[i] = Exclusive /\ s.cache[j] = Exclusive -> i = j}
        invariant {forall i: int. 0 <= i < n /\ not s.exgntd -> s.cache[i] <> Exclusive}
        invariant {forall i: int. 0 <= i < n /\ s.cache[i] = Shared -> s.shrset[i]}
        invariant {forall i j: int. 0 <= i < n /\ 0 <= j < n /\ s.cache[i] = Exclusive /\ s.shrset[j] -> i = j}


        let p0 = Random.random_int n in

        (* Req_shared *)
        if coin () && s.curcmd = Empty && s.cache[p0] = Invalid then begin
           s.curcmd <- Reqs;
           s.curptr <- p0;
        end
        (* req_exclusive *)
        else if coin () && s.curcmd = Empty && s.cache[p0] <> Exclusive then begin
           s.curcmd <- Reqe;
           s.curptr <- p0;
        end
        (* inv_1 *)
        else if coin () && s.shrset[p0] && s.curcmd = Reqe then begin
	   label Inv_1 in
           s.exgntd <- false;
           for _j8 = 0 to s.cache.length - 1 do
	       invariant {forall p':proc. 0 <= p' < _j8 ->
	       		  (p' = p0 -> s.cache[p'] = Invalid) /\
			  (p' <> p0 -> s.cache[p'] = (s.cache[p'] at Inv_1))}
	       invariant {forall p':proc. _j8 <= p' < n ->
	       		 s.cache[p'] = (s.cache[p'] at Inv_1)}
	       s.cache[_j8] <- (
	       		  if _j8 = p0 then Invalid
			  else s.cache[_j8])
	   done;
           for i = 0 to s.cache.length - 1 do
	       invariant {forall p':proc. 0 <= p' < i ->
	       		  p' = p0 -> s.shrset[p'] = False}
	       invariant {forall p':proc. p' <> p0 ->
	       		  s.shrset[p'] = (s.shrset[p'] at Inv_1)}
	       if i = p0 then s.shrset[i] <- false;
	   done;
        end
        (* inv_2 *)
        else if coin () && s.shrset[p0] && s.curcmd = Reqs && s.exgntd then begin
           s.exgntd <- false;
           s.cache[p0] <- Invalid;
           s.shrset[p0] <- false;
        end
        (* gnt_shared *)
        else if coin () && s.curptr = p0 && s.curcmd = Reqs && not s.exgntd then begin
           s.curcmd <- Empty;
           s.cache[p0] <- Shared;
           s.shrset[p0] <- true;
        end
        (* gnt_exclusive *)
        else if coin () && s.curcmd = Reqe && not s.exgntd && s.curptr = p0
                && forall_other_gnt_exclusive s.shrset p0 then begin
           s.exgntd <- true;
           s.cache[p0] <- Exclusive;
           s.shrset[p0] <- true;
           s.curcmd <- Empty;
        end
    done;
    s
end
