module Germanish

use import array.Array
use import int.Int
use import ref.Refint
use import random.Random

scope import Msg

  type msg = Empty | Reqs | Reqe

  let (=) (a b: msg): bool
    ensures { result <-> a = b }
  = match a, b with
    | Empty, Empty | Reqs, Reqs | Reqe, Reqe -> true
    | _ -> false end

end

scope import State

  type state = Invalid | Shared | Exclusive

  let (=) (a b: state): bool
    ensures { result <-> a = b }
  = match a, b with
    | Invalid, Invalid | Shared, Shared | Exclusive, Exclusive -> true
    | _ -> false end

end

let empty_shared (shrset : array bool)
    ensures {result = True <-> forall proc:int. 0 <= proc < shrset.length -> not shrset[proc]}
=
     let res = ref true in
     for proc = 0 to shrset.length - 1 do
         invariant {!res = True <-> forall p:int. 0 <= p < proc -> not shrset[p]}
         if shrset[proc] then res := false
     done;
     !res

val coin () : bool

let germanish (n:int) : array state
    diverges
    requires {0 < n}
    ensures {forall i j : int. 0 <= i < n /\ 0 <= j < n /\
                    result[i] = Exclusive /\ result[j] <> Invalid -> i = j}
=                   
    let exgntd = ref false in
    let curcmd = ref Empty in
    let curptr = ref (Random.random_int n) in
    
    let cache = Array.make n Invalid in
    let shrset = Array.make n false in

    while true do
        (* invariant {forall i: int. 0 <= i < n /\ cache[i] = Exclusive -> !curptr = i} *)
        invariant {forall i j : int. 0 <= i < n /\ 0 <= j < n /\ cache[i] = Exclusive /\ cache[j] = Exclusive -> i = j}
        invariant {forall i: int. 0 <= i < n /\ not !exgntd -> cache[i] <> Exclusive}
        invariant {forall i: int. 0 <= i < n /\ cache[i] = Shared -> shrset[i]}
        invariant {forall i j: int. 0 <= i < n /\ 0 <= j < n /\ cache[i] = Exclusive /\ shrset[j] -> i = j}


        let proc = Random.random_int n in

        (* Req_shared *)
        if coin () && !curcmd = Empty && cache[proc] = Invalid then begin
           curcmd := Reqs;
           curptr := proc;
        end
        (* req_exclusive *)
        else if coin () && !curcmd = Empty && cache[proc] <> Exclusive then begin
           curcmd := Reqe;
           curptr := proc;
        end
        (* inv_1 *)
        else if coin () && shrset[proc] && !curcmd = Reqe then begin
           exgntd := false;
           cache[proc] <- Invalid;
           shrset[proc] <- false;
        end
        (* inv_2 *)
        else if coin () && shrset[proc] && !curcmd = Reqs && !exgntd then begin
           exgntd := false;
           cache[proc] <- Invalid;
           shrset[proc] <- false;
        end
        (* gnt_shared *)
        else if coin () && !curptr = proc && !curcmd = Reqs && not !exgntd then begin
           curcmd := Empty;
           cache[proc] <- Shared;
           shrset[proc] <- true;
        end
        (* gnt_exclusive *)
        else if coin () && !curcmd = Reqe && not !exgntd && !curptr = proc
                && empty_shared shrset then begin
           exgntd := true;
           cache[proc] <- Exclusive;
           shrset[proc] <- true;
           curcmd := Empty;
        end
    done;
    cache
end
