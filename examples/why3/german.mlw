module Germanish

use import array.Array
use import int.Int
use import ref.Refint
use import random.Random

scope import Msg

  type msg = Empty | Reqs | Reqe | Inv | Invack | Gnts | Gnte

  let (=) (a b: msg): bool
    ensures { result <-> a = b }
  = match a, b with
    | Empty, Empty | Reqs, Reqs | Reqe, Reqe
    | Inv, Inv | Invack, Invack | Gnts, Gnts | Gnte, Gnte -> true
    | _ -> false end

end

scope import State

  type state = Invalid | Shared | Exclusive

  let (=) (a b: state): bool
    ensures { result <-> a = b }
  = match a, b with
    | Invalid, Invalid | Shared, Shared | Exclusive, Exclusive -> true
    | _ -> false end

end

let empty_shared (shrset : array bool)
    ensures {result = True <-> forall proc:int. 0 <= proc < shrset.length -> not shrset[proc]}
=
     let res = ref true in
     for proc = 0 to shrset.length - 1 do
         invariant {!res = True <-> forall p:int. 0 <= p < proc -> not shrset[p]}
         if shrset[proc] then res := false
     done;
     !res

val coin () : bool


let german (n:int) : array state
    diverges
    requires {0 < n}
    ensures {forall i j : int. 0 <= i < n /\ 0 <= j < n /\
                    result[i] = Exclusive /\ result[j] <> Invalid -> i = j}
=                   
    let exgntd = ref false in
    let curcmd = ref Empty in
    let curclient = ref (Random.random_int n) in

    let chan1 = Array.make n Empty in
    let chan2 = Array.make n Empty in
    let chan3 = Array.make n Empty in
    let cache = Array.make n Invalid in
    let invset = Array.make n false in
    let shrset = Array.make n false in

    while true do
        invariant {forall i:int. 0 <= i < n /\ cache[i] = Exclusive -> !exgntd}
        invariant {forall i:int. 0 <= i < n /\ cache[i] <> Exclusive -> shrset[i]}

        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Gnte -> !exgntd}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Gnts -> shrset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Gnte -> shrset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Gnts -> chan3[i] <> Invack}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Gnte -> chan3[i] <> Invack}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Inv -> shrset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Inv -> chan3[i] <> Invack}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Inv -> !curcmd <> Empty}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Inv -> not invset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan2[i] = Inv /\ !curcmd = Reqs -> !exgntd}

        invariant {forall i:int. 0 <= i < n /\ chan3[i] = Invack -> cache[i] = Invalid}
        invariant {forall i:int. 0 <= i < n /\ chan3[i] = Invack -> shrset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan3[i] = Invack -> !curcmd <> Empty}
        invariant {forall i:int. 0 <= i < n /\ chan3[i] = Invack -> not invset[i]}
        invariant {forall i:int. 0 <= i < n /\ chan3[i] = Invack /\ !curcmd = Reqs -> !exgntd}
        
        invariant {forall i:int. 0 <= i < n /\ invset[i] -> shrset[i]}

        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ chan2[i] = Gnte -> chan3[j] <> Invack}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ cache[i] = Exclusive -> chan3[j] <> Invack}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ chan2[i] = Gnte -> chan2[j] <> Inv}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ cache[i] = Exclusive -> chan2[j] <> Inv}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ chan2[i] = Gnte -> not invset[j]}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ cache[i] = Exclusive -> not invset[j]}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ chan2[i] = Gnte -> not shrset[j]}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ cache[i] = Exclusive -> not shrset[j]}

        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ invset[i] /\ chan3[j] = Invack -> !curcmd <> Reqs}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ chan2[i] = Inv /\ chan2[j] = Inv -> !curcmd <> Reqs}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ invset[i] /\ chan2[j] = Inv -> !curcmd <> Reqs}

        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ invset[i] /\ invset[j] -> not !exgntd}
        invariant {forall i j:int. 0 <= i < n /\ 0 <= j < n /\ i <> j /\ shrset[i] /\ shrset[j] -> not !exgntd}
    
        let proc = Random.random_int n in

        (* send_req_shared *)
        if cache[proc] = Invalid && chan1[proc] = Empty then begin
           chan1[proc] <- Reqs;
        end

        (* send_req_exclusive *)
        else if coin () && cache[proc] <> Exclusive && chan1[proc] = Empty then begin
           chan1[proc] <- Reqe;
        end

        (* recv_req_shared *)
        else if coin () && !curcmd = Empty && chan1[proc] = Reqs then begin
           curcmd := Reqs;
           curclient := proc;
           for p = 0 to n - 1 do
               invset[p] <- shrset[p]
           done;
           chan1[proc] <- Empty
        end

        (* recv_req_exclusive *)
        else if coin () && !curcmd = Empty && chan1[proc] = Reqe then begin
           curcmd := Reqe;
           curclient := proc;
           for p = 0 to n - 1 do
               invset[p] <- shrset[p]
           done;
           chan1[proc] <- Empty
        end

        (* send_inv_1 *)
        else if coin () && chan2[proc] = Empty && invset[proc] && !curcmd = Reqe then
        begin
           chan2[proc] <- Inv;
           invset[proc] <- false;
        end

        (* send_inv_1 *)
        else if coin () && chan2[proc] = Empty && invset[proc] &&
                !curcmd = Reqs && !exgntd then
        begin
           chan2[proc] <- Inv;
           invset[proc] <- false;
        end

        (* send_invack *)
        else if coin () && chan2[proc] = Inv && chan3[proc] = Empty then
        begin
           chan2[proc] <- Empty;
           chan3[proc] <- Invack;
           cache[proc] <- Invalid;
        end

        (* recv_invack *)
        else if coin () && chan3[proc] = Invack && !curcmd <> Empty then
        begin
           exgntd := false;
           chan3[proc] <- Empty;
           shrset[proc] <- false;
        end

        (* send_gnt_shared *)
        else if coin () && !curclient = proc && !curcmd = Reqs &&
                not !exgntd && chan2[proc] = Empty then begin
           curcmd := Empty;
           chan2[proc] <- Gnts;
           shrset[proc] <- true;
        end

        (* send_gnt_exclusive *)
        else if coin () && !curcmd = Reqe && not !exgntd && !curclient = proc
                && empty_shared shrset then begin
           exgntd := true;
           curcmd := Empty;
           chan2[proc] <- Gnte;
           shrset[proc] <- true;
        end

        (* recv_gnt_shared *)
        else if coin () && chan2[proc] = Gnts then begin
           chan2[proc] <- Empty;
           cache[proc] <- Shared;
        end

        (* recv_gnt_exclusive *)
        else if coin () && chan2[proc] = Gnte then begin
           chan2[proc] <- Empty;
           cache[proc] <- Exclusive;
        end
    done;
    cache
end
