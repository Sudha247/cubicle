(*

Cache Coherence Protocol (Steve German, 2001)

ExGntd   |------|                                 |-----------|
CurCmd   |      | <-- Chan1 (excl/shared req.) -- |           |  Invalide/
CurPtr   | Home | --- Chan2 (grants or inv.) ---> | Client(i) |  Shared/
InvSet   |      | <-- Chan3 (inv. ack) ---------- |           |  Exclusive
ShrSet   |------|                                 |-----------|


*)

type state = Invalid | Shared | Exclusive
type msg = Empty | Reqs | Reqe | Inv | Invack | Gnts | Gnte

var Exgntd : bool
var Curcmd : msg
var CurClient : proc

array Chan1[proc] : msg
array Chan2[proc] : msg
array Chan3[proc] : msg
array Cache[proc] : state
array Invset[proc] : bool
array Shrset[proc] : bool

init (z) { 		   
     Chan1[z] = Empty &&
     Chan2[z] = Empty &&
     Chan3[z] = Empty &&
     Cache[z] = Invalid &&
     Invset[z] = False &&
     Shrset[z] = False &&
     Curcmd=Empty &&
     Exgntd = False }

(* invariant (z1) {Exgntd = False && Cache[z1] = Exclusive} *)
(* invariant (z1) {Cache[z1] = Exclusive && Shrset[z1] = False} *)
(* invariant (z1) {Cache[z1] <> Invalid && Shrset[z1] = False} *)
(* invariant (z1) {Exgntd = False && Chan2[z1] = Gnte} *)
(* invariant (z1) {Chan2[z1] = Gnts && Shrset[z1] = False} *)
(* invariant (z1) {Chan3[z1] = Invack && Cache[z1] = Exclusive} *)
(* invariant (z1) {Chan2[z1] = Gnte && Shrset[z1] = False} *)
(* invariant (z1) {Chan3[z1] = Invack && Cache[z1] <> Invalid} *)
(* invariant (z1) {Chan2[z1] = Gnte && Chan3[z1] = Invack} *)
(* invariant (z1) {Chan2[z1] = Gnts && Chan3[z1] = Invack} *)
(* invariant (z1) {Chan3[z1] = Invack && Shrset[z1] = False} *)
(* invariant (z1) {Chan2[z1] = Inv && Shrset[z1] = False} *)
(* invariant (z1) {Curcmd = Empty && Chan3[z1] = Invack} *)
(* invariant (z1) {Chan2[z1] = Inv && Chan3[z1] = Invack} *)
(* invariant (z1) {Invset[z1] = True && Shrset[z1] = False} *)
(* invariant (z1) {Curcmd = Empty && Chan2[z1] = Inv} *)
(* invariant (z1) {Chan3[z1] = Invack && Invset[z1] = True} *)
(* invariant (z1) {Chan2[z1] = Inv && Invset[z1] = True} *)
(* invariant (z1) {Exgntd = True && Chan2[z1] = Gnts} *)
(* invariant (z1) {Exgntd = False && Curcmd = Reqs && Chan3[z1] = Invack} *)
(* invariant (z1) {Exgntd = False && Curcmd = Reqs && Chan2[z1] = Inv} *)
(* invariant (z1 z2) {Chan2[z1] = Gnte && Chan3[z2] = Invack} *)
(* invariant (z1 z2) {Chan3[z2] = Invack && Cache[z1] = Exclusive} *)
(* invariant (z1 z2) {Chan2[z1] = Gnte && Chan2[z2] = Inv} *)
(* invariant (z1 z2) {Chan2[z2] = Inv && Cache[z1] = Exclusive} *)
(* invariant (z1 z2) {Chan2[z1] = Gnte && Invset[z2] = True} *)
(* invariant (z1 z2) {Cache[z1] = Exclusive && Invset[z2] = True} *)
(* invariant (z1 z2) {Chan2[z1] = Gnte && Shrset[z2] = True} *)
(* invariant (z1 z2) {Cache[z1] = Exclusive && Shrset[z2] = True} *)


(*unsafe (z1 z2) { Cache[z1] = Exclusive && Cache[z2] = Shared  }*)

(*unsafe (z1 z2) { Cache[z1] = Exclusive && Cache[z2] = Exclusive }*)
unsafe (z1 z2) { Cache[z1] = Exclusive && Cache[z2] <> Invalid }
(* unsafe (z) { Chan3[z] = Invack && Shrset[z] = False } *)
(* trans_regexp : send_req_shared(z) recv_req_shared(z) send_gnt_shared(z) ; *)
(*                (\* recv_gnt_shared(z)?; *\) *)
(* trans_regexp : send_inv_1(z) send_invack(z); *)

(* meta_transition meta_shared_3(n) *)
(* requires { Cache[n] = Invalid && Chan1[n] = Empty &&  *)
(*            Curcmd = Empty && Exgntd = False && Chan2[n] = Empty } *)
(* {  *)
(*   Curcmd := Reqs;  *)
(*   CurClient := n;  *)
(*   Invset[j] := case | _ : Shrset[j]; *)
(*   Chan2[j] := case  *)
(*   	        | j = n : Gnts  *)
(* 	        | _ : Chan2[j] ; *)
(*   Shrset[j] := case  *)
(* 	        | j = n : True  *)
(* 		| _ : Shrset[j] ; *)
(* } *)

(* meta_transition meta_shared_4(n) *)
(* requires { Cache[n] = Invalid && Chan1[n] = Empty && *)
(*            Curcmd = Empty && Exgntd = False && Chan2[n] = Empty } *)
(* { *)
(*   Invset[j] := case | _ : Shrset[j]; *)
(*   Shrset[j] := case *)
(* 	        | j = n : True *)
(* 		| _ : Shrset[j] ; *)
(*   Cache[j] := case *)
(*                | j = n : Shared *)
(* 	       | _ : Cache[j] ; *)
(* } *)

(* meta_transition meta_inv_1(n) *)
(* requires { Chan2[n] = Empty && Invset[n] = True && Curcmd = Reqe && Chan3[n] = Empty } *)
(* { *)
(*   Chan2[j] := case *)
(*   	       | j = n : Empty  *)
(* 	       | _ : Chan2[j] ; *)
(*   Chan3[j] := case *)
(*   	       | j = n : Invack  *)
(* 	       | _ : Chan3[j] ; *)
(*   Cache[j] := case  *)
(*   	       | j = n : Invalid  *)
(* 	       | _ : Cache[j] ; *)
(*   Invset[j] := case *)
(*   	       | j = n : False  *)
(* 	       | _ : Invset[j]; *)
(* } *)


(* meta_transition meta_exclusive_3(n) *)
(* requires { Cache[n] <> Exclusive && Chan1[n] = Empty && Curcmd = Empty && *)
(*            Chan2[n] = Empty && Shrset[n] = False &&  *)
(*            forall_other j. Shrset[j] = False } *)
(* {  *)
(*   CurClient := n;  *)
(*   Invset[j] := case | _ : Shrset[j]; *)
(*   Exgntd := True ; *)
(*   Chan2[j] := case *)
(*                | j = n : Gnte  *)
(* 	       | _ : Chan2[j] ; *)
(*   Shrset[j] := case  *)
(* 	       | j = n : True  *)
(* 	       | _ : Shrset[j] ; *)
(* } *)


(* meta_transition meta_exclusive_4(n) *)
(* requires { Cache[n] <> Exclusive && Chan1[n] = Empty && Curcmd = Empty && *)
(*            Chan2[n] = Empty && Shrset[n] = False && *)
(*            forall_other j. Shrset[j] = False } *)
(* { *)
(*   CurClient := n; *)
(*   Invset[j] := case | _ : Shrset[j]; *)
(*   Exgntd := True ; *)
(*   Shrset[j] := case *)
(* 	       | j = n : True *)
(* 	       | _ : Shrset[j] ; *)
(*   Cache[j] := case  *)
(*                | j = n : Exclusive  *)
(* 	       | _ : Cache[j] ; *)
(* } *)

(* universal_transition univ_shared(n) *)
(* requires { Cache[n] = Invalid && Chan1[n] = Empty &&  *)
(*            Curcmd = Empty && Exgntd = False && Chan2[n] = Empty } *)
(* {  *)
(*   Curcmd := Reqs; *)
(*   CurClient := n;  *)
(*   Invset[j] := case | _ : Shrset[j] ; *)
(*   Chan1[j] := case | _ : Empty ; *)
(*   Chan2[j] := case | _ : Gnts ; *)
(*   Shrset[j] := case | _ : True ; *)
(* } *)

(* universal_transition univ_inv_1(n) *)
(* requires { Chan2[n] = Empty && Invset[n] = True && Curcmd = Reqe && Chan3[n] = Empty } *)
(* { *)
(*   Chan2[j] := case | _ : Empty ; *)
(*   Chan3[j] := case | _ : Invack ; *)
(*   Cache[j] := case | _ : Invalid ; *)
(*   Invset[j] := case | _ : False ; *)
(* } *)

transition send_req_shared(n)
requires { Cache[n] = Invalid && Chan1[n] = Empty }
{
  Chan1[j] := case 
  	        | j = n : Reqs 
		| _ : Chan1[j];
}

transition send_req_exclusive_1(n)
requires { Cache[n] = Invalid && Chan1[n] = Empty }
{ 
  Chan1[j] := case
  	       | j = n : Reqe 
	       | _ : Chan1[j] ;
}

transition send_req_exclusive_2(n)
requires { Cache[n] = Shared && Chan1[n] = Empty }
{
  Chan1[j] := case 
   	       | j = n : Reqe 
	       | _ : Chan1[j] ;
}

transition recv_req_shared(n)
requires { Curcmd = Empty && Chan1[n] = Reqs }
{
  Curcmd := Reqs; 
  CurClient := n; 
  Invset[j] := case | _ : Shrset[j];
  Chan1[j] := case 
  	       | j = n: Empty 
	       | _ : Chan1[j];
}

transition recv_req_exclusive(n)
requires { Curcmd = Empty && Chan1[n] = Reqe }
{ 
  Curcmd := Reqe; 
  CurClient := n; 
  Invset[j] := case | _ : Shrset[j];
  Chan1[j] := case 
  	       | j = n : Empty 
	       | _ : Chan1[j] ;
}

transition send_inv_1(n)
requires { Chan2[n] = Empty && Invset[n] = True && Curcmd = Reqe }
{ 
  Chan2[j] := case
	       | j = n : Inv 
	       | _ : Chan2[j] ;
  Invset[j] := case
  	       | j = n : False 
	       | _ : Invset[j];
}

transition send_inv_2(n)
requires { Chan2[n] = Empty && Invset[n] = True && 
	  Curcmd = Reqs && Exgntd = True}
{ 
  Chan2[j] := case
  	       | j = n : Inv 
	       | _ : Chan2[j] ;
  Invset[j] := case 
  	       | j = n : False 
	       | _ : Invset[j] ;
}

transition send_invack(n)
requires { Chan2[n] = Inv && Chan3[n] = Empty }
{
  Chan2[j] := case
  	       | j = n : Empty 
	       | _ : Chan2[j] ;
  Chan3[j] := case
  	       | j = n : Invack 
	       | _ : Chan3[j] ;
  Cache[j] := case 
  	       | j = n : Invalid 
	       | _ : Cache[j] ;
}
    
transition recv_invack(n)
requires { Chan3[n] = Invack && Curcmd <> Empty }
{ 
  Exgntd := False;
  Chan3[j] := case 
  	       | j = n : Empty 
	       | _ : Chan3[j] ;
  Shrset[j] := case
  	        | j = n : False 
		| _ : Shrset[j] ;
}

transition send_gnt_shared(n)
requires { CurClient = n && Curcmd = Reqs && 
	  Exgntd = False && Chan2[n] = Empty }
{ 	  
  Curcmd := Empty;
  Chan2[j] := case 
  	       | j = n : Gnts 
	       | _ : Chan2[j] ;
  Shrset[j] := case 
	        | j = n : True 
		| _ : Shrset[j] ;
}

transition send_gnt_exclusive(n)
requires { CurClient = n && Curcmd = Reqe &&
	  Chan2[n] = Empty && Shrset[n] = False && 
          forall_other j. Shrset[j] = False }
{ 
  Curcmd := Empty; 
  Exgntd := True ;
  Chan2[j] := case
               | j = n : Gnte 
	       | _ : Chan2[j] ;
  Shrset[j] := case 
	       | j = n : True 
	       | _ : Shrset[j] ;
}

transition recv_gnt_shared(n)
requires { Chan2[n] = Gnts }
{
  Cache[j] := case 
               | j = n : Shared 
	       | _ : Cache[j] ;
  Chan2[j] := case 
	       | j = n : Empty 
	       | _ : Chan2[j] ;
}

transition recv_gnt_exclusive(n)
requires { Chan2[n] = Gnte }
{
  Cache[j] := case 
               | j = n : Exclusive 
	       | _ : Cache[j] ;
  Chan2[j] := case 
	       | j = n : Empty 
	       | _ : Chan2[j] ;
}
