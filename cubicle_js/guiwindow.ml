(* open Psystem_parser *)
(* open Lexing *)
(* open Options *)
(* open Format *)
(* open Js *)

(* class type aceEditor =  *)
(* object  *)
(*   method getLastVisibleRow : unit Js.t -> Js.number Js.t Js.meth *)
(*   method getValue : unit Js.t -> Js.js_string Js.t Js.meth *)
(*   method on : Js.js_string Js.t -> (Js.Unsafe.any Js.t -> unit) Js.callback -> unit Js.meth *)
(* end *)

(* exception CursorNotOverText  *)
(* exception FileError *)
(* exception KillThread *)
(* exception Value_mode_error *)
(* exception Match *)

(* let last_search_iter = ref None  *)

(* let trans_args = ref [] *)

(* let kill_thread = ref false *)

(* let wd = if double then 1600 else 1000 *)

(* module M = Map.Make (String) *)

(* let var_map = ref M.empty  *)

(* let add_marker i j k l =  *)
(*   Js.Unsafe.fun_call (Js.Unsafe.js_expr "add_marker")  *)
(*     [|Js.Unsafe.inject i; Js.Unsafe.inject j;Js.Unsafe.inject k;Js.Unsafe.inject l|]  *)
    
(* let remove_maker id =   Js.Unsafe.fun_call (Js.Unsafe.js_expr "remove_marker")  *)
(*   [|Js.Unsafe.inject id|]  *)

    
(* let list_to_string l  =   *)
(*   List.fold_right (fun x acc -> acc ^ x ^ "\n") l "" *)


(* let match_condition s sep l t = *)
(*   let arg_list = !trans_args in *)
(*   try *)
(*     ignore (Str.search_forward sep s 0); *)
(*     (match Str.split sep s with *)
(*       |a::b::[] -> *)
(*         (let a, b =  *)
(*           try  *)
(*             ignore (float_of_string (String.trim a)); *)
(*             print_endline (b^"TEST"^a); *)
(*             (String.trim b, String.trim a) *)
(*           with Failure(_) -> (String.trim a, String.trim b) in *)
(*           try *)
(*             let open_b = (Str.search_forward (Str.regexp "\\[") a  0) + 1 in *)
(*             let close_b = Str.search_forward (Str.regexp "\\]") a 0 in *)
(*             let arg = String.sub a open_b  (close_b - open_b) in *)
(*             let (r, _) = List.find (fun (_, x) -> x = arg) arg_list in *)
(*            (\* Printf.printf "var : %s\n" r;  *\) *)
(*            (\* print_newline (); *\) *)
(*             let new_var = Str.replace_first (Str.regexp "\\[.*\\]") ("["^r^"]") a in *)
(*             l := (new_var, ([b], t)) :: !l *)
(*           with Not_found ->  *)
(*             try  *)
(*               let (r, n) = List.find (fun (_, x) -> x = b) arg_list in   *)
(*               l := (a, ([r], t)) :: !l *)
(*             with Not_found -> l := (a, ([b], t)) :: !l)           *)
(*       |_ -> failwith "pb match_condition guiwindow"); *)
(*     raise Match *)
(*   with Not_found -> () *)
    
(* let mode_var () = *)
(*   let condition_list = ref [] in  *)
(*   M.iter (fun x _ ->  *)
(*     try  *)
(*       match_condition x (Str.regexp ">=") condition_list Ed_graph.GreaterEq; *)
(*       match_condition x (Str.regexp "<=") condition_list Ed_graph.LessEq; *)
(*       match_condition x (Str.regexp "<>") condition_list Ed_graph.NEq; *)
(*       match_condition x (Str.regexp ">")  condition_list Ed_graph.Greater; *)
(*       match_condition x (Str.regexp "<")  condition_list Ed_graph.Less; *)
(*       match_condition x (Str.regexp "=")  condition_list Ed_graph.Eq; *)
(*       failwith "pb format mode_var guiwindow" *)
(*     with Match -> () *)
(*   ) !var_map; *)
(*   !condition_list  *)
    

(* let add_value_var l =  *)
(*   try  *)
(*     List.iter (fun (x, e) ->  *)
(*       if e#text = "" then  *)
(*         (if !Ed_main.mode_value then *)
(*             begin *)
(*               GToolbox.message_box  *)
(*                 ~title:"Error" "Please enter a value or choose change mode"; *)
(*               raise Value_mode_error *)
(*             end; *)
(*          Ed_main.var_l := (x, ([], Ed_graph.Eq))::!Ed_main.var_l) *)
(*       else *)
(*         let str_l = Str.split (Str.regexp ";") e#text in  *)
(*         let str_l = (str_l, Ed_graph.Eq) in *)
(*         Ed_main.var_l := (x, str_l)::!Ed_main.var_l) l; *)
(*     var_map := M.empty; *)
(*     true *)
(*   with Value_mode_error -> false *)
    

(* let get_mouse_coordinates e = *)
(*   e##getDocumentPosition() *)

(* (\** Envoie a Psystem_parser la position courante du curseur dans le buffer *\) *)
(* let get_buffer_coordinates e  =  *)
(*   let pos = get_mouse_coordinates e in  *)
(*   let i =  *)
(*   (\* let buffer_x, buffer_y = source#window_to_buffer_coords `TEXT mouse_x mouse_y in  *\) *)
(*   (\* let iter = source#get_iter_at_location buffer_x buffer_y in  *\) *)
(*   (\* if not iter#inside_sentence then  *\) *)
(*   (\*   (buffer_l := -1; *\) *)
(*   (\*    buffer_c := -1; *\) *)
(*   (\*    raise CursorNotOverText); *\) *)
(*   (\* buffer_l := 1 + iter#line;  *\) *)
(*   (\* buffer_c := iter#offset *\) *)

(* let rec apply_tag d = function  *)
(*   |[] -> () *)
(*   |(t_id, start, stop)::s ->  *)
(*     let (startl, startc) = d##indexToPosition (start) in  *)
(*     let (stopl, stopc) = d##indexToPostion (stop) in  *)
(*     (match t_id with  *)
(*     |Comment ->  () *)
(*       (\* source#source_buffer#apply_tag_by_name "delete" *\) *)
(*       (\*   ~start:start_iter ~stop:stop_iter; *\) *)
(*       (\* source#source_buffer#apply_tag_by_name "dark" *\) *)
(*       (\*   ~start:start_iter ~stop:stop_iter; *\) *)
(*       |Hover -> add_marker startk startc stop l stop c *)
(*         (\* source#source_buffer#apply_tag_by_name "gray_background"  *\) *)
(*         (\*   ~start:start_iter ~stop:stop_iter; apply_tag s *\) *)
(*       |UndoComment -> () *)
(*         (\* source#source_buffer#remove_tag_by_name "delete" *\) *)
(*         (\*   ~start:start_iter ~stop:stop_iter; *\) *)
(*         (\* source#source_buffer#remove_tag_by_name "dark" *\) *)
(*         (\*   ~start:start_iter ~stop:stop_iter *\) *)
(*       |UndoHover -> () *)
(*         (\* source#source_buffer#remove_tag_by_name "gray_background"  *\) *)
(*         (\*   ~start:start_iter ~stop:stop_iter *\) *)
(*       |Var -> () *)
(*         (\* begin *\) *)
(*         (\*   source#source_buffer#apply_tag_by_name "var" *\) *)
(*         (\*     ~start:start_iter ~stop:stop_iter; *\) *)
(*         (\*   let str =  (source#source_buffer#get_text ~start:start_iter ~stop:stop_iter() ) in *\) *)
(*         (\*   if M.mem str !var_map then  *\) *)
(*         (\*     (let (be, en) = M.find str !var_map in *\) *)
(*         (\*      if be = start && en = stop then *\) *)
(*         (\*        var_map := M.remove str !var_map ; *\) *)
(*         (\*      source#source_buffer#remove_tag_by_name "var" *\) *)
(*         (\*        ~start:start_iter ~stop:stop_iter) *\) *)
(*         (\*   else  *\) *)
(*         (\*     var_map := M.add str (start, stop) !var_map           *\) *)
(*         (\* end *\) *)
(*     ); *)
(*     apply_tag s *)

(* (\** Parcourt l'AST pour trouver dans les bornes de quelle loc se trouve le curseur *\) *)
(* let find_in_ast s editor session document m  =  *)
(*   if !edit then  *)
(*     false *)
(*   else  *)
(*     try  *)
(*       get_buffer_coordinates m; *)
(*       apply_tag d (parse_psystem !s); *)
(*       false *)
(*     with CursorNotOverText  -> (apply_tag (cancel_last_visited ()); false) *)

(* (\** Appelé après un clic de souris pour commenter *\) *)
(* let modify_ast ast editor session document b =  *)
(*   if !edit then false *)
(*     else  *)
(*       if (GdkEvent.Button.button b) = 3 && !buffer_l <> -1 && !buffer_c <> -1 then  *)
(*         (apply_tag (parse_var !ast); true) *)
(*       else  *)
(*         (if !buffer_l <> -1 && !buffer_c <> -1 then *)
(*             begin *)
(*               apply_tag (parse_psystem_m !ast); *)
(*               source2#source_buffer#set_text (Psystem_printer.psystem_to_string !ast) *)
(*             end; *)
(*          true) *)



(* (\** Coordonées fichier sauvegarde session *\) *)
(* let rec list_position l =  *)
(*   match l with  *)
(*     |[] |_::[] -> [] *)
(*     |x::y::s -> (int_of_string x, int_of_string y)::list_position s *)

(* let open_file inter_path save_path ast =  *)
(*   (try *)
(*      let ic = open_in inter_path in *)
(*      let lb = from_channel ic in *)
(*      ast := Parser.system Lexer.token lb; *)
(*      close_in ic; *)
(*      let str = read_file save_path in  *)
(*      let fl = Str.split (Str.regexp "[ \t]+") str in *)
(*      let pos_l = list_position fl in *)
(*      inact_l := pos_l; *)
(*      parse_init !ast; *)
(*      source#source_buffer#set_text (read_file inter_path); *)
(*      apply_tag (parse_psystem !ast); *)
(*    with Sys_error(_) -> ());; *)



(* let onload s _  =  *)
(*   let ast = ref s in *)
(*   let e = Js.Unsafe.variable "editor" in  *)
(*   let session = e##getSession () in  *)
(*   let d = session##getDocument () in *)
(*   e##on("mousemove", (fun e ->  *)
(*     find_in_ast ast editor session document))() *)
    
(* let _ = *)
(*   let e = Js.Unsafe.variable "editor" in  *)
(*   let str =  *)
(*     "var Turn : proc *)
(* array Want[proc] : bool *)
(* array Crit[proc] : bool *)

(* init (z) { Want[z] = False && Crit[z] = False } *)

(* unsafe (z1 z2) { Crit[z1] = True && Crit[z2] = True } *)

(* transition req (i) *)
(* requires { Want[i] = False } *)
(* { Want[i] := True } *)

(* transition enter (i) *)
(* requires { Want[i]=True && Crit[i] = False && Turn = i} *)
(* { Crit[i] := True; } *)

(* transition exit (i) *)
(* requires { Crit[i] = True } *)
(* {  *)
(*   Turn := . ; *)
(*   Crit[i] := False;  *)
(*   Want[i] := False *)
(* } *)
(* " in *)
(*   e##value <- str *)
(*   let lb = from_string str in  *)
(*   Dom_html.window##onload <- Dom_html.handler onload (Parser.system Lexer.token lb) *)
