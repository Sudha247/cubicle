State 0:
system' -> . system [ # ]
-- On SIZEPROC shift to state 1
-- On system shift to state 3
-- On size_proc shift to state 4
-- On VAR reduce production size_proc -> 
-- On UNSAFE reduce production size_proc -> 
-- On TYPE reduce production size_proc -> 
-- On TREGEXP reduce production size_proc -> 
-- On TRANSITION reduce production size_proc -> 
-- On PREDICATE reduce production size_proc -> 
-- On INVARIANT reduce production size_proc -> 
-- On INIT reduce production size_proc -> 
-- On GOOD reduce production size_proc -> 
-- On CONST reduce production size_proc -> 
-- On ARRAY reduce production size_proc -> 

State 1:
size_proc -> SIZEPROC . INT [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On INT shift to state 2

State 2:
size_proc -> SIZEPROC INT . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production size_proc -> SIZEPROC INT 
-- On UNSAFE reduce production size_proc -> SIZEPROC INT 
-- On TYPE reduce production size_proc -> SIZEPROC INT 
-- On TREGEXP reduce production size_proc -> SIZEPROC INT 
-- On TRANSITION reduce production size_proc -> SIZEPROC INT 
-- On PREDICATE reduce production size_proc -> SIZEPROC INT 
-- On INVARIANT reduce production size_proc -> SIZEPROC INT 
-- On INIT reduce production size_proc -> SIZEPROC INT 
-- On GOOD reduce production size_proc -> SIZEPROC INT 
-- On CONST reduce production size_proc -> SIZEPROC INT 
-- On ARRAY reduce production size_proc -> SIZEPROC INT 

State 3:
system' -> system . [ # ]
-- On # accept system

State 4:
system -> size_proc . type_defs symbold_decls decl_list EOF [ # ]
-- On TYPE shift to state 5
-- On type_defs shift to state 16
-- On type_def_plus shift to state 261
-- On type_def shift to state 262
-- On VAR reduce production type_defs -> 
-- On UNSAFE reduce production type_defs -> 
-- On TREGEXP reduce production type_defs -> 
-- On TRANSITION reduce production type_defs -> 
-- On PREDICATE reduce production type_defs -> 
-- On INVARIANT reduce production type_defs -> 
-- On INIT reduce production type_defs -> 
-- On GOOD reduce production type_defs -> 
-- On CONST reduce production type_defs -> 
-- On ARRAY reduce production type_defs -> 

State 5:
type_def -> TYPE . lident [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def -> TYPE . lident EQ constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def -> TYPE . lident EQ BAR constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LIDENT shift to state 6
-- On lident shift to state 7

State 6:
lident -> LIDENT . [ VAR UNSAFE TYPE TREGEXP TRANSITION THEN RIGHTSQ RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS MIDENT LT LIDENT LEFTPAR LE INVARIANT INIT IMP GT GOOD GE EQUIV EQ EOF ELSE DOT CONST COMMA COLON BAR ARRAY AND ]
-- On VAR reduce production lident -> LIDENT 
-- On UNSAFE reduce production lident -> LIDENT 
-- On TYPE reduce production lident -> LIDENT 
-- On TREGEXP reduce production lident -> LIDENT 
-- On TRANSITION reduce production lident -> LIDENT 
-- On THEN reduce production lident -> LIDENT 
-- On RIGHTSQ reduce production lident -> LIDENT 
-- On RIGHTPAR reduce production lident -> LIDENT 
-- On RIGHTBR reduce production lident -> LIDENT 
-- On PV reduce production lident -> LIDENT 
-- On PREDICATE reduce production lident -> LIDENT 
-- On PLUS reduce production lident -> LIDENT 
-- On OR reduce production lident -> LIDENT 
-- On NEQ reduce production lident -> LIDENT 
-- On MINUS reduce production lident -> LIDENT 
-- On MIDENT reduce production lident -> LIDENT 
-- On LT reduce production lident -> LIDENT 
-- On LIDENT reduce production lident -> LIDENT 
-- On LEFTPAR reduce production lident -> LIDENT 
-- On LE reduce production lident -> LIDENT 
-- On INVARIANT reduce production lident -> LIDENT 
-- On INIT reduce production lident -> LIDENT 
-- On IMP reduce production lident -> LIDENT 
-- On GT reduce production lident -> LIDENT 
-- On GOOD reduce production lident -> LIDENT 
-- On GE reduce production lident -> LIDENT 
-- On EQUIV reduce production lident -> LIDENT 
-- On EQ reduce production lident -> LIDENT 
-- On EOF reduce production lident -> LIDENT 
-- On ELSE reduce production lident -> LIDENT 
-- On DOT reduce production lident -> LIDENT 
-- On CONST reduce production lident -> LIDENT 
-- On COMMA reduce production lident -> LIDENT 
-- On COLON reduce production lident -> LIDENT 
-- On BAR reduce production lident -> LIDENT 
-- On ARRAY reduce production lident -> LIDENT 
-- On AND reduce production lident -> LIDENT 

State 7:
type_def -> TYPE lident . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def -> TYPE lident . EQ constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def -> TYPE lident . EQ BAR constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On EQ shift to state 8
-- On VAR reduce production type_def -> TYPE lident 
-- On UNSAFE reduce production type_def -> TYPE lident 
-- On TYPE reduce production type_def -> TYPE lident 
-- On TREGEXP reduce production type_def -> TYPE lident 
-- On TRANSITION reduce production type_def -> TYPE lident 
-- On PREDICATE reduce production type_def -> TYPE lident 
-- On INVARIANT reduce production type_def -> TYPE lident 
-- On INIT reduce production type_def -> TYPE lident 
-- On GOOD reduce production type_def -> TYPE lident 
-- On CONST reduce production type_def -> TYPE lident 
-- On ARRAY reduce production type_def -> TYPE lident 

State 8:
type_def -> TYPE lident EQ . constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def -> TYPE lident EQ . BAR constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On BAR shift to state 10
-- On mident shift to state 11
-- On constructors shift to state 15

State 9:
mident -> MIDENT . [ VAR UNSAFE TYPE TREGEXP TRANSITION TIMES THEN RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS MIDENT LT LIDENT LEFTSQ LEFTPAR LE INVARIANT INIT IMP GT GOOD GE EQUIV EQ EOF ELSE CONST COMMA COLON BAR ARRAY AND AFFECT ]
-- On VAR reduce production mident -> MIDENT 
-- On UNSAFE reduce production mident -> MIDENT 
-- On TYPE reduce production mident -> MIDENT 
-- On TREGEXP reduce production mident -> MIDENT 
-- On TRANSITION reduce production mident -> MIDENT 
-- On TIMES reduce production mident -> MIDENT 
-- On THEN reduce production mident -> MIDENT 
-- On RIGHTPAR reduce production mident -> MIDENT 
-- On RIGHTBR reduce production mident -> MIDENT 
-- On PV reduce production mident -> MIDENT 
-- On PREDICATE reduce production mident -> MIDENT 
-- On PLUS reduce production mident -> MIDENT 
-- On OR reduce production mident -> MIDENT 
-- On NEQ reduce production mident -> MIDENT 
-- On MINUS reduce production mident -> MIDENT 
-- On MIDENT reduce production mident -> MIDENT 
-- On LT reduce production mident -> MIDENT 
-- On LIDENT reduce production mident -> MIDENT 
-- On LEFTSQ reduce production mident -> MIDENT 
-- On LEFTPAR reduce production mident -> MIDENT 
-- On LE reduce production mident -> MIDENT 
-- On INVARIANT reduce production mident -> MIDENT 
-- On INIT reduce production mident -> MIDENT 
-- On IMP reduce production mident -> MIDENT 
-- On GT reduce production mident -> MIDENT 
-- On GOOD reduce production mident -> MIDENT 
-- On GE reduce production mident -> MIDENT 
-- On EQUIV reduce production mident -> MIDENT 
-- On EQ reduce production mident -> MIDENT 
-- On EOF reduce production mident -> MIDENT 
-- On ELSE reduce production mident -> MIDENT 
-- On CONST reduce production mident -> MIDENT 
-- On COMMA reduce production mident -> MIDENT 
-- On COLON reduce production mident -> MIDENT 
-- On BAR reduce production mident -> MIDENT 
-- On ARRAY reduce production mident -> MIDENT 
-- On AND reduce production mident -> MIDENT 
-- On AFFECT reduce production mident -> MIDENT 

State 10:
type_def -> TYPE lident EQ BAR . constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On mident shift to state 11
-- On constructors shift to state 14

State 11:
constructors -> mident . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
constructors -> mident . BAR constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On BAR shift to state 12
-- On VAR reduce production constructors -> mident 
-- On UNSAFE reduce production constructors -> mident 
-- On TYPE reduce production constructors -> mident 
-- On TREGEXP reduce production constructors -> mident 
-- On TRANSITION reduce production constructors -> mident 
-- On PREDICATE reduce production constructors -> mident 
-- On INVARIANT reduce production constructors -> mident 
-- On INIT reduce production constructors -> mident 
-- On GOOD reduce production constructors -> mident 
-- On CONST reduce production constructors -> mident 
-- On ARRAY reduce production constructors -> mident 

State 12:
constructors -> mident BAR . constructors [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On mident shift to state 11
-- On constructors shift to state 13

State 13:
constructors -> mident BAR constructors . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production constructors -> mident BAR constructors 
-- On UNSAFE reduce production constructors -> mident BAR constructors 
-- On TYPE reduce production constructors -> mident BAR constructors 
-- On TREGEXP reduce production constructors -> mident BAR constructors 
-- On TRANSITION reduce production constructors -> mident BAR constructors 
-- On PREDICATE reduce production constructors -> mident BAR constructors 
-- On INVARIANT reduce production constructors -> mident BAR constructors 
-- On INIT reduce production constructors -> mident BAR constructors 
-- On GOOD reduce production constructors -> mident BAR constructors 
-- On CONST reduce production constructors -> mident BAR constructors 
-- On ARRAY reduce production constructors -> mident BAR constructors 

State 14:
type_def -> TYPE lident EQ BAR constructors . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production type_def -> TYPE lident EQ BAR constructors 
-- On UNSAFE reduce production type_def -> TYPE lident EQ BAR constructors 
-- On TYPE reduce production type_def -> TYPE lident EQ BAR constructors 
-- On TREGEXP reduce production type_def -> TYPE lident EQ BAR constructors 
-- On TRANSITION reduce production type_def -> TYPE lident EQ BAR constructors 
-- On PREDICATE reduce production type_def -> TYPE lident EQ BAR constructors 
-- On INVARIANT reduce production type_def -> TYPE lident EQ BAR constructors 
-- On INIT reduce production type_def -> TYPE lident EQ BAR constructors 
-- On GOOD reduce production type_def -> TYPE lident EQ BAR constructors 
-- On CONST reduce production type_def -> TYPE lident EQ BAR constructors 
-- On ARRAY reduce production type_def -> TYPE lident EQ BAR constructors 

State 15:
type_def -> TYPE lident EQ constructors . [ VAR UNSAFE TYPE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production type_def -> TYPE lident EQ constructors 
-- On UNSAFE reduce production type_def -> TYPE lident EQ constructors 
-- On TYPE reduce production type_def -> TYPE lident EQ constructors 
-- On TREGEXP reduce production type_def -> TYPE lident EQ constructors 
-- On TRANSITION reduce production type_def -> TYPE lident EQ constructors 
-- On PREDICATE reduce production type_def -> TYPE lident EQ constructors 
-- On INVARIANT reduce production type_def -> TYPE lident EQ constructors 
-- On INIT reduce production type_def -> TYPE lident EQ constructors 
-- On GOOD reduce production type_def -> TYPE lident EQ constructors 
-- On CONST reduce production type_def -> TYPE lident EQ constructors 
-- On ARRAY reduce production type_def -> TYPE lident EQ constructors 

State 16:
system -> size_proc type_defs . symbold_decls decl_list EOF [ # ]
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 41
-- On const_decl shift to state 37
-- On array_decl shift to state 39
-- On UNSAFE reduce production symbold_decls -> 
-- On TREGEXP reduce production symbold_decls -> 
-- On TRANSITION reduce production symbold_decls -> 
-- On PREDICATE reduce production symbold_decls -> 
-- On INVARIANT reduce production symbold_decls -> 
-- On INIT reduce production symbold_decls -> 
-- On GOOD reduce production symbold_decls -> 

State 17:
var_decl -> VAR . mident COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On mident shift to state 18

State 18:
var_decl -> VAR mident . COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On COLON shift to state 19

State 19:
var_decl -> VAR mident COLON . lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LIDENT shift to state 6
-- On lident shift to state 20

State 20:
var_decl -> VAR mident COLON lident . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production var_decl -> VAR mident COLON lident 
-- On UNSAFE reduce production var_decl -> VAR mident COLON lident 
-- On TREGEXP reduce production var_decl -> VAR mident COLON lident 
-- On TRANSITION reduce production var_decl -> VAR mident COLON lident 
-- On PREDICATE reduce production var_decl -> VAR mident COLON lident 
-- On INVARIANT reduce production var_decl -> VAR mident COLON lident 
-- On INIT reduce production var_decl -> VAR mident COLON lident 
-- On GOOD reduce production var_decl -> VAR mident COLON lident 
-- On CONST reduce production var_decl -> VAR mident COLON lident 
-- On ARRAY reduce production var_decl -> VAR mident COLON lident 

State 21:
const_decl -> CONST . mident COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On mident shift to state 22

State 22:
const_decl -> CONST mident . COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On COLON shift to state 23

State 23:
const_decl -> CONST mident COLON . lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LIDENT shift to state 6
-- On lident shift to state 24

State 24:
const_decl -> CONST mident COLON lident . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production const_decl -> CONST mident COLON lident 
-- On UNSAFE reduce production const_decl -> CONST mident COLON lident 
-- On TREGEXP reduce production const_decl -> CONST mident COLON lident 
-- On TRANSITION reduce production const_decl -> CONST mident COLON lident 
-- On PREDICATE reduce production const_decl -> CONST mident COLON lident 
-- On INVARIANT reduce production const_decl -> CONST mident COLON lident 
-- On INIT reduce production const_decl -> CONST mident COLON lident 
-- On GOOD reduce production const_decl -> CONST mident COLON lident 
-- On CONST reduce production const_decl -> CONST mident COLON lident 
-- On ARRAY reduce production const_decl -> CONST mident COLON lident 

State 25:
array_decl -> ARRAY . mident LEFTSQ lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On MIDENT shift to state 9
-- On mident shift to state 26

State 26:
array_decl -> ARRAY mident . LEFTSQ lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LEFTSQ shift to state 27

State 27:
array_decl -> ARRAY mident LEFTSQ . lident_list_plus RIGHTSQ COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 28
-- On lident shift to state 32

State 28:
array_decl -> ARRAY mident LEFTSQ lident_list_plus . RIGHTSQ COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On RIGHTSQ shift to state 29

State 29:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ . COLON lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On COLON shift to state 30

State 30:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON . lident [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On LIDENT shift to state 6
-- On lident shift to state 31

State 31:
array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On UNSAFE reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On TREGEXP reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On TRANSITION reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On PREDICATE reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On INVARIANT reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On INIT reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On GOOD reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On CONST reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 
-- On ARRAY reduce production array_decl -> ARRAY mident LEFTSQ lident_list_plus RIGHTSQ COLON lident 

State 32:
lident_list_plus -> lident . [ RIGHTSQ RIGHTPAR ]
lident_list_plus -> lident . COMMA lident_list_plus [ RIGHTSQ RIGHTPAR ]
-- On COMMA shift to state 33
-- On RIGHTSQ reduce production lident_list_plus -> lident 
-- On RIGHTPAR reduce production lident_list_plus -> lident 

State 33:
lident_list_plus -> lident COMMA . lident_list_plus [ RIGHTSQ RIGHTPAR ]
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 34
-- On lident shift to state 32

State 34:
lident_list_plus -> lident COMMA lident_list_plus . [ RIGHTSQ RIGHTPAR ]
-- On RIGHTSQ reduce production lident_list_plus -> lident COMMA lident_list_plus 
-- On RIGHTPAR reduce production lident_list_plus -> lident COMMA lident_list_plus 

State 35:
symbold_decls -> var_decl . symbold_decls [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 36
-- On const_decl shift to state 37
-- On array_decl shift to state 39
-- On UNSAFE reduce production symbold_decls -> 
-- On TREGEXP reduce production symbold_decls -> 
-- On TRANSITION reduce production symbold_decls -> 
-- On PREDICATE reduce production symbold_decls -> 
-- On INVARIANT reduce production symbold_decls -> 
-- On INIT reduce production symbold_decls -> 
-- On GOOD reduce production symbold_decls -> 

State 36:
symbold_decls -> var_decl symbold_decls . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On UNSAFE reduce production symbold_decls -> var_decl symbold_decls 
-- On TREGEXP reduce production symbold_decls -> var_decl symbold_decls 
-- On TRANSITION reduce production symbold_decls -> var_decl symbold_decls 
-- On PREDICATE reduce production symbold_decls -> var_decl symbold_decls 
-- On INVARIANT reduce production symbold_decls -> var_decl symbold_decls 
-- On INIT reduce production symbold_decls -> var_decl symbold_decls 
-- On GOOD reduce production symbold_decls -> var_decl symbold_decls 

State 37:
symbold_decls -> const_decl . symbold_decls [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 38
-- On const_decl shift to state 37
-- On array_decl shift to state 39
-- On UNSAFE reduce production symbold_decls -> 
-- On TREGEXP reduce production symbold_decls -> 
-- On TRANSITION reduce production symbold_decls -> 
-- On PREDICATE reduce production symbold_decls -> 
-- On INVARIANT reduce production symbold_decls -> 
-- On INIT reduce production symbold_decls -> 
-- On GOOD reduce production symbold_decls -> 

State 38:
symbold_decls -> const_decl symbold_decls . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On UNSAFE reduce production symbold_decls -> const_decl symbold_decls 
-- On TREGEXP reduce production symbold_decls -> const_decl symbold_decls 
-- On TRANSITION reduce production symbold_decls -> const_decl symbold_decls 
-- On PREDICATE reduce production symbold_decls -> const_decl symbold_decls 
-- On INVARIANT reduce production symbold_decls -> const_decl symbold_decls 
-- On INIT reduce production symbold_decls -> const_decl symbold_decls 
-- On GOOD reduce production symbold_decls -> const_decl symbold_decls 

State 39:
symbold_decls -> array_decl . symbold_decls [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On VAR shift to state 17
-- On CONST shift to state 21
-- On ARRAY shift to state 25
-- On var_decl shift to state 35
-- On symbold_decls shift to state 40
-- On const_decl shift to state 37
-- On array_decl shift to state 39
-- On UNSAFE reduce production symbold_decls -> 
-- On TREGEXP reduce production symbold_decls -> 
-- On TRANSITION reduce production symbold_decls -> 
-- On PREDICATE reduce production symbold_decls -> 
-- On INVARIANT reduce production symbold_decls -> 
-- On INIT reduce production symbold_decls -> 
-- On GOOD reduce production symbold_decls -> 

State 40:
symbold_decls -> array_decl symbold_decls . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD ]
-- On UNSAFE reduce production symbold_decls -> array_decl symbold_decls 
-- On TREGEXP reduce production symbold_decls -> array_decl symbold_decls 
-- On TRANSITION reduce production symbold_decls -> array_decl symbold_decls 
-- On PREDICATE reduce production symbold_decls -> array_decl symbold_decls 
-- On INVARIANT reduce production symbold_decls -> array_decl symbold_decls 
-- On INIT reduce production symbold_decls -> array_decl symbold_decls 
-- On GOOD reduce production symbold_decls -> array_decl symbold_decls 

State 41:
system -> size_proc type_defs symbold_decls . decl_list EOF [ # ]
-- On UNSAFE shift to state 42
-- On TREGEXP shift to state 161
-- On TRANSITION shift to state 172
-- On PREDICATE shift to state 214
-- On INVARIANT shift to state 223
-- On INIT shift to state 233
-- On GOOD shift to state 243
-- On unsafe shift to state 250
-- On transition shift to state 251
-- On invariant shift to state 252
-- On init shift to state 253
-- On good shift to state 254
-- On function_decl shift to state 255
-- On decl_regexp shift to state 256
-- On decl_list shift to state 257
-- On decl shift to state 259

State 42:
unsafe -> UNSAFE . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
unsafe -> UNSAFE . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 43
-- On LEFTBR shift to state 158

State 43:
unsafe -> UNSAFE LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 45
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents -> 

State 44:
lidents -> lidents_plus . [ RIGHTPAR ]
-- On RIGHTPAR reduce production lidents -> lidents_plus 

State 45:
unsafe -> UNSAFE LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 46

State 46:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 47

State 47:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 154
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 48:
literal -> TRUE . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> TRUE 
-- On RIGHTPAR reduce production literal -> TRUE 
-- On RIGHTBR reduce production literal -> TRUE 
-- On OR reduce production literal -> TRUE 
-- On IMP reduce production literal -> TRUE 
-- On EQUIV reduce production literal -> TRUE 
-- On ELSE reduce production literal -> TRUE 
-- On COMMA reduce production literal -> TRUE 
-- On COLON reduce production literal -> TRUE 
-- On AND reduce production literal -> TRUE 

State 49:
constnum -> REAL . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production constnum -> REAL 
-- On RIGHTPAR reduce production constnum -> REAL 
-- On RIGHTBR reduce production constnum -> REAL 
-- On PV reduce production constnum -> REAL 
-- On OR reduce production constnum -> REAL 
-- On NEQ reduce production constnum -> REAL 
-- On LT reduce production constnum -> REAL 
-- On LE reduce production constnum -> REAL 
-- On IMP reduce production constnum -> REAL 
-- On GT reduce production constnum -> REAL 
-- On GE reduce production constnum -> REAL 
-- On EQUIV reduce production constnum -> REAL 
-- On EQ reduce production constnum -> REAL 
-- On ELSE reduce production constnum -> REAL 
-- On COMMA reduce production constnum -> REAL 
-- On COLON reduce production constnum -> REAL 
-- On BAR reduce production constnum -> REAL 
-- On AND reduce production constnum -> REAL 

State 50:
expr -> NOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 153
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 51:
arith_term -> MINUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On INT shift to state 52

State 52:
arith_term -> MINUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 53

State 53:
arith_term -> MINUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On MIDENT shift to state 9
-- On mident shift to state 54

State 54:
arith_term -> MINUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> MINUS INT TIMES mident 
-- On RIGHTPAR reduce production arith_term -> MINUS INT TIMES mident 
-- On RIGHTBR reduce production arith_term -> MINUS INT TIMES mident 
-- On PV reduce production arith_term -> MINUS INT TIMES mident 
-- On OR reduce production arith_term -> MINUS INT TIMES mident 
-- On NEQ reduce production arith_term -> MINUS INT TIMES mident 
-- On LT reduce production arith_term -> MINUS INT TIMES mident 
-- On LE reduce production arith_term -> MINUS INT TIMES mident 
-- On IMP reduce production arith_term -> MINUS INT TIMES mident 
-- On GT reduce production arith_term -> MINUS INT TIMES mident 
-- On GE reduce production arith_term -> MINUS INT TIMES mident 
-- On EQUIV reduce production arith_term -> MINUS INT TIMES mident 
-- On EQ reduce production arith_term -> MINUS INT TIMES mident 
-- On ELSE reduce production arith_term -> MINUS INT TIMES mident 
-- On COMMA reduce production arith_term -> MINUS INT TIMES mident 
-- On COLON reduce production arith_term -> MINUS INT TIMES mident 
-- On BAR reduce production arith_term -> MINUS INT TIMES mident 
-- On AND reduce production arith_term -> MINUS INT TIMES mident 

State 55:
simple_expr -> LEFTPAR . expr RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 151
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 56:
arith_term -> INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 57
-- On THEN reduce production constnum -> INT 
-- On RIGHTPAR reduce production constnum -> INT 
-- On RIGHTBR reduce production constnum -> INT 
-- On PV reduce production constnum -> INT 
-- On OR reduce production constnum -> INT 
-- On NEQ reduce production constnum -> INT 
-- On LT reduce production constnum -> INT 
-- On LE reduce production constnum -> INT 
-- On IMP reduce production constnum -> INT 
-- On GT reduce production constnum -> INT 
-- On GE reduce production constnum -> INT 
-- On EQUIV reduce production constnum -> INT 
-- On EQ reduce production constnum -> INT 
-- On ELSE reduce production constnum -> INT 
-- On COMMA reduce production constnum -> INT 
-- On COLON reduce production constnum -> INT 
-- On BAR reduce production constnum -> INT 
-- On AND reduce production constnum -> INT 

State 57:
arith_term -> INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On MIDENT shift to state 9
-- On mident shift to state 58

State 58:
arith_term -> INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> INT TIMES mident 
-- On RIGHTPAR reduce production arith_term -> INT TIMES mident 
-- On RIGHTBR reduce production arith_term -> INT TIMES mident 
-- On PV reduce production arith_term -> INT TIMES mident 
-- On OR reduce production arith_term -> INT TIMES mident 
-- On NEQ reduce production arith_term -> INT TIMES mident 
-- On LT reduce production arith_term -> INT TIMES mident 
-- On LE reduce production arith_term -> INT TIMES mident 
-- On IMP reduce production arith_term -> INT TIMES mident 
-- On GT reduce production arith_term -> INT TIMES mident 
-- On GE reduce production arith_term -> INT TIMES mident 
-- On EQUIV reduce production arith_term -> INT TIMES mident 
-- On EQ reduce production arith_term -> INT TIMES mident 
-- On ELSE reduce production arith_term -> INT TIMES mident 
-- On COMMA reduce production arith_term -> INT TIMES mident 
-- On COLON reduce production arith_term -> INT TIMES mident 
-- On BAR reduce production arith_term -> INT TIMES mident 
-- On AND reduce production arith_term -> INT TIMES mident 

State 59:
expr -> IF . expr THEN expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 146
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 60:
expr -> FORALL_OTHER . lident DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On LIDENT shift to state 6
-- On lident shift to state 61

State 61:
expr -> FORALL_OTHER lident . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On DOT shift to state 62

State 62:
expr -> FORALL_OTHER lident DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 145
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 63:
expr -> FORALL . lidents_plus_distinct DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 64
-- On lident shift to state 140

State 64:
expr -> FORALL lidents_plus_distinct . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On DOT shift to state 65

State 65:
expr -> FORALL lidents_plus_distinct DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 144
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 66:
literal -> FALSE . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> FALSE 
-- On RIGHTPAR reduce production literal -> FALSE 
-- On RIGHTBR reduce production literal -> FALSE 
-- On OR reduce production literal -> FALSE 
-- On IMP reduce production literal -> FALSE 
-- On EQUIV reduce production literal -> FALSE 
-- On ELSE reduce production literal -> FALSE 
-- On COMMA reduce production literal -> FALSE 
-- On COLON reduce production literal -> FALSE 
-- On AND reduce production literal -> FALSE 

State 67:
expr -> EXISTS_OTHER . lident DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On LIDENT shift to state 6
-- On lident shift to state 68

State 68:
expr -> EXISTS_OTHER lident . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On DOT shift to state 69

State 69:
expr -> EXISTS_OTHER lident DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 143
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 70:
expr -> EXISTS . lidents_plus_distinct DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 71
-- On lident shift to state 140

State 71:
expr -> EXISTS lidents_plus_distinct . DOT expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On DOT shift to state 72

State 72:
expr -> EXISTS lidents_plus_distinct DOT . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 139
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 73:
const_proc -> CONSTPROC . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production const_proc -> CONSTPROC 
-- On RIGHTSQ reduce production const_proc -> CONSTPROC 
-- On RIGHTPAR reduce production const_proc -> CONSTPROC 
-- On RIGHTBR reduce production const_proc -> CONSTPROC 
-- On PV reduce production const_proc -> CONSTPROC 
-- On PLUS reduce production const_proc -> CONSTPROC 
-- On OR reduce production const_proc -> CONSTPROC 
-- On NEQ reduce production const_proc -> CONSTPROC 
-- On MINUS reduce production const_proc -> CONSTPROC 
-- On LT reduce production const_proc -> CONSTPROC 
-- On LE reduce production const_proc -> CONSTPROC 
-- On IMP reduce production const_proc -> CONSTPROC 
-- On GT reduce production const_proc -> CONSTPROC 
-- On GE reduce production const_proc -> CONSTPROC 
-- On EQUIV reduce production const_proc -> CONSTPROC 
-- On EQ reduce production const_proc -> CONSTPROC 
-- On ELSE reduce production const_proc -> CONSTPROC 
-- On COMMA reduce production const_proc -> CONSTPROC 
-- On COLON reduce production const_proc -> CONSTPROC 
-- On BAR reduce production const_proc -> CONSTPROC 
-- On AND reduce production const_proc -> CONSTPROC 

State 74:
top_id_term -> var_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_or_array_term -> var_term . [ PLUS MINUS ]
-- On THEN reduce production top_id_term -> var_term 
-- On RIGHTPAR reduce production top_id_term -> var_term 
-- On RIGHTBR reduce production top_id_term -> var_term 
-- On PV reduce production top_id_term -> var_term 
-- On PLUS reduce production var_or_array_term -> var_term 
-- On OR reduce production top_id_term -> var_term 
-- On NEQ reduce production top_id_term -> var_term 
-- On MINUS reduce production var_or_array_term -> var_term 
-- On LT reduce production top_id_term -> var_term 
-- On LE reduce production top_id_term -> var_term 
-- On IMP reduce production top_id_term -> var_term 
-- On GT reduce production top_id_term -> var_term 
-- On GE reduce production top_id_term -> var_term 
-- On EQUIV reduce production top_id_term -> var_term 
-- On EQ reduce production top_id_term -> var_term 
-- On ELSE reduce production top_id_term -> var_term 
-- On COMMA reduce production top_id_term -> var_term 
-- On COLON reduce production top_id_term -> var_term 
-- On BAR reduce production top_id_term -> var_term 
-- On AND reduce production top_id_term -> var_term 

State 75:
arith_term -> var_or_array_term . PLUS constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . PLUS mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term . MINUS mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On PLUS shift to state 76
-- On MINUS shift to state 84

State 76:
arith_term -> var_or_array_term PLUS . constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS . mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On REAL shift to state 49
-- On MIDENT shift to state 9
-- On INT shift to state 77
-- On mident shift to state 80
-- On constnum shift to state 83

State 77:
arith_term -> var_or_array_term PLUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 78
-- On THEN reduce production constnum -> INT 
-- On RIGHTPAR reduce production constnum -> INT 
-- On RIGHTBR reduce production constnum -> INT 
-- On PV reduce production constnum -> INT 
-- On OR reduce production constnum -> INT 
-- On NEQ reduce production constnum -> INT 
-- On LT reduce production constnum -> INT 
-- On LE reduce production constnum -> INT 
-- On IMP reduce production constnum -> INT 
-- On GT reduce production constnum -> INT 
-- On GE reduce production constnum -> INT 
-- On EQUIV reduce production constnum -> INT 
-- On EQ reduce production constnum -> INT 
-- On ELSE reduce production constnum -> INT 
-- On COMMA reduce production constnum -> INT 
-- On COLON reduce production constnum -> INT 
-- On BAR reduce production constnum -> INT 
-- On AND reduce production constnum -> INT 

State 78:
arith_term -> var_or_array_term PLUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On MIDENT shift to state 9
-- On mident shift to state 79

State 79:
arith_term -> var_or_array_term PLUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On RIGHTBR reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On PV reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On OR reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On NEQ reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On LT reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On LE reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On IMP reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On GT reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On GE reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On EQUIV reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On EQ reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On ELSE reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On COMMA reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On COLON reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On BAR reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 
-- On AND reduce production arith_term -> var_or_array_term PLUS INT TIMES mident 

State 80:
arith_term -> var_or_array_term PLUS mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term PLUS mident . TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 81
-- On THEN reduce production arith_term -> var_or_array_term PLUS mident 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term PLUS mident 
-- On RIGHTBR reduce production arith_term -> var_or_array_term PLUS mident 
-- On PV reduce production arith_term -> var_or_array_term PLUS mident 
-- On OR reduce production arith_term -> var_or_array_term PLUS mident 
-- On NEQ reduce production arith_term -> var_or_array_term PLUS mident 
-- On LT reduce production arith_term -> var_or_array_term PLUS mident 
-- On LE reduce production arith_term -> var_or_array_term PLUS mident 
-- On IMP reduce production arith_term -> var_or_array_term PLUS mident 
-- On GT reduce production arith_term -> var_or_array_term PLUS mident 
-- On GE reduce production arith_term -> var_or_array_term PLUS mident 
-- On EQUIV reduce production arith_term -> var_or_array_term PLUS mident 
-- On EQ reduce production arith_term -> var_or_array_term PLUS mident 
-- On ELSE reduce production arith_term -> var_or_array_term PLUS mident 
-- On COMMA reduce production arith_term -> var_or_array_term PLUS mident 
-- On COLON reduce production arith_term -> var_or_array_term PLUS mident 
-- On BAR reduce production arith_term -> var_or_array_term PLUS mident 
-- On AND reduce production arith_term -> var_or_array_term PLUS mident 

State 81:
arith_term -> var_or_array_term PLUS mident TIMES . INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On INT shift to state 82

State 82:
arith_term -> var_or_array_term PLUS mident TIMES INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On RIGHTBR reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On PV reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On OR reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On NEQ reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On LT reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On LE reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On IMP reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On GT reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On GE reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On EQUIV reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On EQ reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On ELSE reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On COMMA reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On COLON reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On BAR reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 
-- On AND reduce production arith_term -> var_or_array_term PLUS mident TIMES INT 

State 83:
arith_term -> var_or_array_term PLUS constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term PLUS constnum 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term PLUS constnum 
-- On RIGHTBR reduce production arith_term -> var_or_array_term PLUS constnum 
-- On PV reduce production arith_term -> var_or_array_term PLUS constnum 
-- On OR reduce production arith_term -> var_or_array_term PLUS constnum 
-- On NEQ reduce production arith_term -> var_or_array_term PLUS constnum 
-- On LT reduce production arith_term -> var_or_array_term PLUS constnum 
-- On LE reduce production arith_term -> var_or_array_term PLUS constnum 
-- On IMP reduce production arith_term -> var_or_array_term PLUS constnum 
-- On GT reduce production arith_term -> var_or_array_term PLUS constnum 
-- On GE reduce production arith_term -> var_or_array_term PLUS constnum 
-- On EQUIV reduce production arith_term -> var_or_array_term PLUS constnum 
-- On EQ reduce production arith_term -> var_or_array_term PLUS constnum 
-- On ELSE reduce production arith_term -> var_or_array_term PLUS constnum 
-- On COMMA reduce production arith_term -> var_or_array_term PLUS constnum 
-- On COLON reduce production arith_term -> var_or_array_term PLUS constnum 
-- On BAR reduce production arith_term -> var_or_array_term PLUS constnum 
-- On AND reduce production arith_term -> var_or_array_term PLUS constnum 

State 84:
arith_term -> var_or_array_term MINUS . constnum [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . INT TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS . mident TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On REAL shift to state 49
-- On MIDENT shift to state 9
-- On INT shift to state 85
-- On mident shift to state 88
-- On constnum shift to state 91

State 85:
arith_term -> var_or_array_term MINUS INT . TIMES mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
constnum -> INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 86
-- On THEN reduce production constnum -> INT 
-- On RIGHTPAR reduce production constnum -> INT 
-- On RIGHTBR reduce production constnum -> INT 
-- On PV reduce production constnum -> INT 
-- On OR reduce production constnum -> INT 
-- On NEQ reduce production constnum -> INT 
-- On LT reduce production constnum -> INT 
-- On LE reduce production constnum -> INT 
-- On IMP reduce production constnum -> INT 
-- On GT reduce production constnum -> INT 
-- On GE reduce production constnum -> INT 
-- On EQUIV reduce production constnum -> INT 
-- On EQ reduce production constnum -> INT 
-- On ELSE reduce production constnum -> INT 
-- On COMMA reduce production constnum -> INT 
-- On COLON reduce production constnum -> INT 
-- On BAR reduce production constnum -> INT 
-- On AND reduce production constnum -> INT 

State 86:
arith_term -> var_or_array_term MINUS INT TIMES . mident [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On MIDENT shift to state 9
-- On mident shift to state 87

State 87:
arith_term -> var_or_array_term MINUS INT TIMES mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On RIGHTBR reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On PV reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On OR reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On NEQ reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On LT reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On LE reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On IMP reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On GT reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On GE reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On EQUIV reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On EQ reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On ELSE reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On COMMA reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On COLON reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On BAR reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 
-- On AND reduce production arith_term -> var_or_array_term MINUS INT TIMES mident 

State 88:
arith_term -> var_or_array_term MINUS mident . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
arith_term -> var_or_array_term MINUS mident . TIMES INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On TIMES shift to state 89
-- On THEN reduce production arith_term -> var_or_array_term MINUS mident 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term MINUS mident 
-- On RIGHTBR reduce production arith_term -> var_or_array_term MINUS mident 
-- On PV reduce production arith_term -> var_or_array_term MINUS mident 
-- On OR reduce production arith_term -> var_or_array_term MINUS mident 
-- On NEQ reduce production arith_term -> var_or_array_term MINUS mident 
-- On LT reduce production arith_term -> var_or_array_term MINUS mident 
-- On LE reduce production arith_term -> var_or_array_term MINUS mident 
-- On IMP reduce production arith_term -> var_or_array_term MINUS mident 
-- On GT reduce production arith_term -> var_or_array_term MINUS mident 
-- On GE reduce production arith_term -> var_or_array_term MINUS mident 
-- On EQUIV reduce production arith_term -> var_or_array_term MINUS mident 
-- On EQ reduce production arith_term -> var_or_array_term MINUS mident 
-- On ELSE reduce production arith_term -> var_or_array_term MINUS mident 
-- On COMMA reduce production arith_term -> var_or_array_term MINUS mident 
-- On COLON reduce production arith_term -> var_or_array_term MINUS mident 
-- On BAR reduce production arith_term -> var_or_array_term MINUS mident 
-- On AND reduce production arith_term -> var_or_array_term MINUS mident 

State 89:
arith_term -> var_or_array_term MINUS mident TIMES . INT [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On INT shift to state 90

State 90:
arith_term -> var_or_array_term MINUS mident TIMES INT . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On RIGHTBR reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On PV reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On OR reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On NEQ reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On LT reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On LE reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On IMP reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On GT reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On GE reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On EQUIV reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On EQ reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On ELSE reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On COMMA reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On COLON reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On BAR reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 
-- On AND reduce production arith_term -> var_or_array_term MINUS mident TIMES INT 

State 91:
arith_term -> var_or_array_term MINUS constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> var_or_array_term MINUS constnum 
-- On RIGHTPAR reduce production arith_term -> var_or_array_term MINUS constnum 
-- On RIGHTBR reduce production arith_term -> var_or_array_term MINUS constnum 
-- On PV reduce production arith_term -> var_or_array_term MINUS constnum 
-- On OR reduce production arith_term -> var_or_array_term MINUS constnum 
-- On NEQ reduce production arith_term -> var_or_array_term MINUS constnum 
-- On LT reduce production arith_term -> var_or_array_term MINUS constnum 
-- On LE reduce production arith_term -> var_or_array_term MINUS constnum 
-- On IMP reduce production arith_term -> var_or_array_term MINUS constnum 
-- On GT reduce production arith_term -> var_or_array_term MINUS constnum 
-- On GE reduce production arith_term -> var_or_array_term MINUS constnum 
-- On EQUIV reduce production arith_term -> var_or_array_term MINUS constnum 
-- On EQ reduce production arith_term -> var_or_array_term MINUS constnum 
-- On ELSE reduce production arith_term -> var_or_array_term MINUS constnum 
-- On COMMA reduce production arith_term -> var_or_array_term MINUS constnum 
-- On COLON reduce production arith_term -> var_or_array_term MINUS constnum 
-- On BAR reduce production arith_term -> var_or_array_term MINUS constnum 
-- On AND reduce production arith_term -> var_or_array_term MINUS constnum 

State 92:
term -> top_id_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production term -> top_id_term 
-- On RIGHTPAR reduce production term -> top_id_term 
-- On RIGHTBR reduce production term -> top_id_term 
-- On PV reduce production term -> top_id_term 
-- On OR reduce production term -> top_id_term 
-- On NEQ reduce production term -> top_id_term 
-- On LT reduce production term -> top_id_term 
-- On LE reduce production term -> top_id_term 
-- On IMP reduce production term -> top_id_term 
-- On GT reduce production term -> top_id_term 
-- On GE reduce production term -> top_id_term 
-- On EQUIV reduce production term -> top_id_term 
-- On EQ reduce production term -> top_id_term 
-- On ELSE reduce production term -> top_id_term 
-- On COMMA reduce production term -> top_id_term 
-- On COLON reduce production term -> top_id_term 
-- On BAR reduce production term -> top_id_term 
-- On AND reduce production term -> top_id_term 

State 93:
literal -> term . EQ term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . NEQ term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . LT term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . LE term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . GT term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
literal -> term . GE term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On NEQ shift to state 94
-- On LT shift to state 109
-- On LE shift to state 111
-- On GT shift to state 113
-- On GE shift to state 115
-- On EQ shift to state 117

State 94:
literal -> term NEQ . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 95
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 95:
literal -> term NEQ term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term NEQ term 
-- On RIGHTPAR reduce production literal -> term NEQ term 
-- On RIGHTBR reduce production literal -> term NEQ term 
-- On OR reduce production literal -> term NEQ term 
-- On IMP reduce production literal -> term NEQ term 
-- On EQUIV reduce production literal -> term NEQ term 
-- On ELSE reduce production literal -> term NEQ term 
-- On COMMA reduce production literal -> term NEQ term 
-- On COLON reduce production literal -> term NEQ term 
-- On AND reduce production literal -> term NEQ term 

State 96:
var_term -> proc_name . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production var_term -> proc_name 
-- On RIGHTPAR reduce production var_term -> proc_name 
-- On RIGHTBR reduce production var_term -> proc_name 
-- On PV reduce production var_term -> proc_name 
-- On PLUS reduce production var_term -> proc_name 
-- On OR reduce production var_term -> proc_name 
-- On NEQ reduce production var_term -> proc_name 
-- On MINUS reduce production var_term -> proc_name 
-- On LT reduce production var_term -> proc_name 
-- On LE reduce production var_term -> proc_name 
-- On IMP reduce production var_term -> proc_name 
-- On GT reduce production var_term -> proc_name 
-- On GE reduce production var_term -> proc_name 
-- On EQUIV reduce production var_term -> proc_name 
-- On EQ reduce production var_term -> proc_name 
-- On ELSE reduce production var_term -> proc_name 
-- On COMMA reduce production var_term -> proc_name 
-- On COLON reduce production var_term -> proc_name 
-- On BAR reduce production var_term -> proc_name 
-- On AND reduce production var_term -> proc_name 

State 97:
array_term -> mident . LEFTSQ proc_name_list_plus RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_term -> mident . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On LEFTSQ shift to state 98
-- On THEN reduce production var_term -> mident 
-- On RIGHTPAR reduce production var_term -> mident 
-- On RIGHTBR reduce production var_term -> mident 
-- On PV reduce production var_term -> mident 
-- On PLUS reduce production var_term -> mident 
-- On OR reduce production var_term -> mident 
-- On NEQ reduce production var_term -> mident 
-- On MINUS reduce production var_term -> mident 
-- On LT reduce production var_term -> mident 
-- On LE reduce production var_term -> mident 
-- On IMP reduce production var_term -> mident 
-- On GT reduce production var_term -> mident 
-- On GE reduce production var_term -> mident 
-- On EQUIV reduce production var_term -> mident 
-- On EQ reduce production var_term -> mident 
-- On ELSE reduce production var_term -> mident 
-- On COMMA reduce production var_term -> mident 
-- On COLON reduce production var_term -> mident 
-- On BAR reduce production var_term -> mident 
-- On AND reduce production var_term -> mident 

State 98:
array_term -> mident LEFTSQ . proc_name_list_plus RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 99
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105

State 99:
array_term -> mident LEFTSQ proc_name_list_plus . RIGHTSQ [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On RIGHTSQ shift to state 100

State 100:
array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ . [ THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On RIGHTPAR reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On RIGHTBR reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On PV reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On PLUS reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On OR reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On NEQ reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On MINUS reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On LT reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On LE reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On IMP reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On GT reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On GE reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On EQUIV reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On EQ reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On ELSE reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On COMMA reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On COLON reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On BAR reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 
-- On AND reduce production array_term -> mident LEFTSQ proc_name_list_plus RIGHTSQ 

State 101:
proc_name_list_plus -> proc_name . [ RIGHTSQ ]
proc_name_list_plus -> proc_name . COMMA proc_name_list_plus [ RIGHTSQ ]
-- On COMMA shift to state 102
-- On RIGHTSQ reduce production proc_name_list_plus -> proc_name 

State 102:
proc_name_list_plus -> proc_name COMMA . proc_name_list_plus [ RIGHTSQ ]
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 103
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105

State 103:
proc_name_list_plus -> proc_name COMMA proc_name_list_plus . [ RIGHTSQ ]
-- On RIGHTSQ reduce production proc_name_list_plus -> proc_name COMMA proc_name_list_plus 

State 104:
proc_name -> lident . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR MINUS IMP EQUIV ELSE COMMA COLON BAR AND ]
-- On THEN reduce production proc_name -> lident 
-- On RIGHTSQ reduce production proc_name -> lident 
-- On RIGHTPAR reduce production proc_name -> lident 
-- On RIGHTBR reduce production proc_name -> lident 
-- On PV reduce production proc_name -> lident 
-- On PLUS reduce production proc_name -> lident 
-- On OR reduce production proc_name -> lident 
-- On MINUS reduce production proc_name -> lident 
-- On IMP reduce production proc_name -> lident 
-- On EQUIV reduce production proc_name -> lident 
-- On ELSE reduce production proc_name -> lident 
-- On COMMA reduce production proc_name -> lident 
-- On COLON reduce production proc_name -> lident 
-- On BAR reduce production proc_name -> lident 
-- On AND reduce production proc_name -> lident 

State 105:
proc_name -> const_proc . [ THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production proc_name -> const_proc 
-- On RIGHTSQ reduce production proc_name -> const_proc 
-- On RIGHTPAR reduce production proc_name -> const_proc 
-- On RIGHTBR reduce production proc_name -> const_proc 
-- On PV reduce production proc_name -> const_proc 
-- On PLUS reduce production proc_name -> const_proc 
-- On OR reduce production proc_name -> const_proc 
-- On NEQ reduce production proc_name -> const_proc 
-- On MINUS reduce production proc_name -> const_proc 
-- On LT reduce production proc_name -> const_proc 
-- On LE reduce production proc_name -> const_proc 
-- On IMP reduce production proc_name -> const_proc 
-- On GT reduce production proc_name -> const_proc 
-- On GE reduce production proc_name -> const_proc 
-- On EQUIV reduce production proc_name -> const_proc 
-- On EQ reduce production proc_name -> const_proc 
-- On ELSE reduce production proc_name -> const_proc 
-- On COMMA reduce production proc_name -> const_proc 
-- On COLON reduce production proc_name -> const_proc 
-- On BAR reduce production proc_name -> const_proc 
-- On AND reduce production proc_name -> const_proc 

State 106:
arith_term -> constnum . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production arith_term -> constnum 
-- On RIGHTPAR reduce production arith_term -> constnum 
-- On RIGHTBR reduce production arith_term -> constnum 
-- On PV reduce production arith_term -> constnum 
-- On OR reduce production arith_term -> constnum 
-- On NEQ reduce production arith_term -> constnum 
-- On LT reduce production arith_term -> constnum 
-- On LE reduce production arith_term -> constnum 
-- On IMP reduce production arith_term -> constnum 
-- On GT reduce production arith_term -> constnum 
-- On GE reduce production arith_term -> constnum 
-- On EQUIV reduce production arith_term -> constnum 
-- On EQ reduce production arith_term -> constnum 
-- On ELSE reduce production arith_term -> constnum 
-- On COMMA reduce production arith_term -> constnum 
-- On COLON reduce production arith_term -> constnum 
-- On BAR reduce production arith_term -> constnum 
-- On AND reduce production arith_term -> constnum 

State 107:
term -> array_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
var_or_array_term -> array_term . [ PLUS MINUS ]
-- On THEN reduce production term -> array_term 
-- On RIGHTPAR reduce production term -> array_term 
-- On RIGHTBR reduce production term -> array_term 
-- On PV reduce production term -> array_term 
-- On PLUS reduce production var_or_array_term -> array_term 
-- On OR reduce production term -> array_term 
-- On NEQ reduce production term -> array_term 
-- On MINUS reduce production var_or_array_term -> array_term 
-- On LT reduce production term -> array_term 
-- On LE reduce production term -> array_term 
-- On IMP reduce production term -> array_term 
-- On GT reduce production term -> array_term 
-- On GE reduce production term -> array_term 
-- On EQUIV reduce production term -> array_term 
-- On EQ reduce production term -> array_term 
-- On ELSE reduce production term -> array_term 
-- On COMMA reduce production term -> array_term 
-- On COLON reduce production term -> array_term 
-- On BAR reduce production term -> array_term 
-- On AND reduce production term -> array_term 

State 108:
term -> arith_term . [ THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND ]
-- On THEN reduce production term -> arith_term 
-- On RIGHTPAR reduce production term -> arith_term 
-- On RIGHTBR reduce production term -> arith_term 
-- On PV reduce production term -> arith_term 
-- On OR reduce production term -> arith_term 
-- On NEQ reduce production term -> arith_term 
-- On LT reduce production term -> arith_term 
-- On LE reduce production term -> arith_term 
-- On IMP reduce production term -> arith_term 
-- On GT reduce production term -> arith_term 
-- On GE reduce production term -> arith_term 
-- On EQUIV reduce production term -> arith_term 
-- On EQ reduce production term -> arith_term 
-- On ELSE reduce production term -> arith_term 
-- On COMMA reduce production term -> arith_term 
-- On COLON reduce production term -> arith_term 
-- On BAR reduce production term -> arith_term 
-- On AND reduce production term -> arith_term 

State 109:
literal -> term LT . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 110
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 110:
literal -> term LT term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term LT term 
-- On RIGHTPAR reduce production literal -> term LT term 
-- On RIGHTBR reduce production literal -> term LT term 
-- On OR reduce production literal -> term LT term 
-- On IMP reduce production literal -> term LT term 
-- On EQUIV reduce production literal -> term LT term 
-- On ELSE reduce production literal -> term LT term 
-- On COMMA reduce production literal -> term LT term 
-- On COLON reduce production literal -> term LT term 
-- On AND reduce production literal -> term LT term 

State 111:
literal -> term LE . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 112
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 112:
literal -> term LE term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term LE term 
-- On RIGHTPAR reduce production literal -> term LE term 
-- On RIGHTBR reduce production literal -> term LE term 
-- On OR reduce production literal -> term LE term 
-- On IMP reduce production literal -> term LE term 
-- On EQUIV reduce production literal -> term LE term 
-- On ELSE reduce production literal -> term LE term 
-- On COMMA reduce production literal -> term LE term 
-- On COLON reduce production literal -> term LE term 
-- On AND reduce production literal -> term LE term 

State 113:
literal -> term GT . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 114
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 114:
literal -> term GT term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term GT term 
-- On RIGHTPAR reduce production literal -> term GT term 
-- On RIGHTBR reduce production literal -> term GT term 
-- On OR reduce production literal -> term GT term 
-- On IMP reduce production literal -> term GT term 
-- On EQUIV reduce production literal -> term GT term 
-- On ELSE reduce production literal -> term GT term 
-- On COMMA reduce production literal -> term GT term 
-- On COLON reduce production literal -> term GT term 
-- On AND reduce production literal -> term GT term 

State 115:
literal -> term GE . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 116
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 116:
literal -> term GE term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term GE term 
-- On RIGHTPAR reduce production literal -> term GE term 
-- On RIGHTBR reduce production literal -> term GE term 
-- On OR reduce production literal -> term GE term 
-- On IMP reduce production literal -> term GE term 
-- On EQUIV reduce production literal -> term GE term 
-- On ELSE reduce production literal -> term GE term 
-- On COMMA reduce production literal -> term GE term 
-- On COLON reduce production literal -> term GE term 
-- On AND reduce production literal -> term GE term 

State 117:
literal -> term EQ . term [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 118
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 118:
literal -> term EQ term . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production literal -> term EQ term 
-- On RIGHTPAR reduce production literal -> term EQ term 
-- On RIGHTBR reduce production literal -> term EQ term 
-- On OR reduce production literal -> term EQ term 
-- On IMP reduce production literal -> term EQ term 
-- On EQUIV reduce production literal -> term EQ term 
-- On ELSE reduce production literal -> term EQ term 
-- On COMMA reduce production literal -> term EQ term 
-- On COLON reduce production literal -> term EQ term 
-- On AND reduce production literal -> term EQ term 

State 119:
expr -> simple_expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production expr -> simple_expr 
-- On RIGHTPAR reduce production expr -> simple_expr 
-- On RIGHTBR reduce production expr -> simple_expr 
-- On OR reduce production expr -> simple_expr 
-- On IMP reduce production expr -> simple_expr 
-- On EQUIV reduce production expr -> simple_expr 
-- On ELSE reduce production expr -> simple_expr 
-- On COMMA reduce production expr -> simple_expr 
-- On COLON reduce production expr -> simple_expr 
-- On AND reduce production expr -> simple_expr 

State 120:
simple_expr -> literal . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production simple_expr -> literal 
-- On RIGHTPAR reduce production simple_expr -> literal 
-- On RIGHTBR reduce production simple_expr -> literal 
-- On OR reduce production simple_expr -> literal 
-- On IMP reduce production simple_expr -> literal 
-- On EQUIV reduce production simple_expr -> literal 
-- On ELSE reduce production simple_expr -> literal 
-- On COMMA reduce production simple_expr -> literal 
-- On COLON reduce production simple_expr -> literal 
-- On AND reduce production simple_expr -> literal 

State 121:
proc_name -> lident . [ RIGHTPAR PLUS NEQ MINUS LT LE GT GE EQ COMMA ]
simple_expr -> lident . LEFTPAR expr_or_term_comma_list RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On LEFTPAR shift to state 122
-- On RIGHTPAR reduce production proc_name -> lident 
-- On PLUS reduce production proc_name -> lident 
-- On NEQ reduce production proc_name -> lident 
-- On MINUS reduce production proc_name -> lident 
-- On LT reduce production proc_name -> lident 
-- On LE reduce production proc_name -> lident 
-- On GT reduce production proc_name -> lident 
-- On GE reduce production proc_name -> lident 
-- On EQ reduce production proc_name -> lident 
-- On COMMA reduce production proc_name -> lident 

State 122:
simple_expr -> lident LEFTPAR . expr_or_term_comma_list RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 137
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
-- On RIGHTPAR reduce production expr_or_term_comma_list -> 

State 123:
expr_or_term_comma_list -> term . [ RIGHTPAR ]
expr_or_term_comma_list -> term . COMMA expr_or_term_comma_list [ RIGHTPAR ]
literal -> term . EQ term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . NEQ term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . LT term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . LE term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . GT term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
literal -> term . GE term [ RIGHTPAR OR IMP EQUIV COMMA AND ]
-- On NEQ shift to state 94
-- On LT shift to state 109
-- On LE shift to state 111
-- On GT shift to state 113
-- On GE shift to state 115
-- On EQ shift to state 117
-- On COMMA shift to state 124
-- On RIGHTPAR reduce production expr_or_term_comma_list -> term 

State 124:
expr_or_term_comma_list -> term COMMA . expr_or_term_comma_list [ RIGHTPAR ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 125
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
-- On RIGHTPAR reduce production expr_or_term_comma_list -> 

State 125:
expr_or_term_comma_list -> term COMMA expr_or_term_comma_list . [ RIGHTPAR ]
-- On RIGHTPAR reduce production expr_or_term_comma_list -> term COMMA expr_or_term_comma_list 

State 126:
expr -> expr . AND expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . OR expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . IMP expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr -> expr . EQUIV expr [ RIGHTPAR OR IMP EQUIV COMMA AND ]
expr_or_term_comma_list -> expr . [ RIGHTPAR ]
expr_or_term_comma_list -> expr . COMMA expr_or_term_comma_list [ RIGHTPAR ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On COMMA shift to state 135
-- On AND shift to state 129
-- On RIGHTPAR reduce production expr_or_term_comma_list -> expr 

State 127:
expr -> expr OR . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 128
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 128:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr OR expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On AND shift to state 129
-- On THEN reduce production expr -> expr OR expr 
-- On RIGHTPAR reduce production expr -> expr OR expr 
-- On RIGHTBR reduce production expr -> expr OR expr 
-- On IMP reduce production expr -> expr OR expr 
-- On EQUIV reduce production expr -> expr OR expr 
-- On ELSE reduce production expr -> expr OR expr 
-- On COMMA reduce production expr -> expr OR expr 
-- On COLON reduce production expr -> expr OR expr 

State 129:
expr -> expr AND . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 130
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 130:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr AND expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On AND shift to state 129
-- On THEN reduce production expr -> expr AND expr 
-- On RIGHTPAR reduce production expr -> expr AND expr 
-- On RIGHTBR reduce production expr -> expr AND expr 
-- On OR reduce production expr -> expr AND expr 
-- On IMP reduce production expr -> expr AND expr 
-- On EQUIV reduce production expr -> expr AND expr 
-- On ELSE reduce production expr -> expr AND expr 
-- On COMMA reduce production expr -> expr AND expr 
-- On COLON reduce production expr -> expr AND expr 

State 131:
expr -> expr IMP . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 132
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 132:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr IMP expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> expr IMP expr 
-- On RIGHTPAR reduce production expr -> expr IMP expr 
-- On RIGHTBR reduce production expr -> expr IMP expr 
-- On ELSE reduce production expr -> expr IMP expr 
-- On COMMA reduce production expr -> expr IMP expr 
-- On COLON reduce production expr -> expr IMP expr 

State 133:
expr -> expr EQUIV . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 134
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 134:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr EQUIV expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> expr EQUIV expr 
-- On RIGHTPAR reduce production expr -> expr EQUIV expr 
-- On RIGHTBR reduce production expr -> expr EQUIV expr 
-- On ELSE reduce production expr -> expr EQUIV expr 
-- On COMMA reduce production expr -> expr EQUIV expr 
-- On COLON reduce production expr -> expr EQUIV expr 

State 135:
expr_or_term_comma_list -> expr COMMA . expr_or_term_comma_list [ RIGHTPAR ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 123
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr_or_term_comma_list shift to state 136
-- On expr shift to state 126
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108
-- On RIGHTPAR reduce production expr_or_term_comma_list -> 

State 136:
expr_or_term_comma_list -> expr COMMA expr_or_term_comma_list . [ RIGHTPAR ]
-- On RIGHTPAR reduce production expr_or_term_comma_list -> expr COMMA expr_or_term_comma_list 

State 137:
simple_expr -> lident LEFTPAR expr_or_term_comma_list . RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On RIGHTPAR shift to state 138

State 138:
simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On RIGHTPAR reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On RIGHTBR reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On OR reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On IMP reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On EQUIV reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On ELSE reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On COMMA reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On COLON reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 
-- On AND reduce production simple_expr -> lident LEFTPAR expr_or_term_comma_list RIGHTPAR 

State 139:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> EXISTS lidents_plus_distinct DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> EXISTS lidents_plus_distinct DOT expr 
-- On RIGHTPAR reduce production expr -> EXISTS lidents_plus_distinct DOT expr 
-- On RIGHTBR reduce production expr -> EXISTS lidents_plus_distinct DOT expr 
-- On ELSE reduce production expr -> EXISTS lidents_plus_distinct DOT expr 
-- On COMMA reduce production expr -> EXISTS lidents_plus_distinct DOT expr 
-- On COLON reduce production expr -> EXISTS lidents_plus_distinct DOT expr 

State 140:
lidents_plus_distinct -> lident . [ DOT ]
lidents_plus_distinct -> lident . NEQ lidents_plus_distinct [ DOT ]
-- On NEQ shift to state 141
-- On DOT reduce production lidents_plus_distinct -> lident 

State 141:
lidents_plus_distinct -> lident NEQ . lidents_plus_distinct [ DOT ]
-- On LIDENT shift to state 6
-- On lidents_plus_distinct shift to state 142
-- On lident shift to state 140

State 142:
lidents_plus_distinct -> lident NEQ lidents_plus_distinct . [ DOT ]
-- On DOT reduce production lidents_plus_distinct -> lident NEQ lidents_plus_distinct 

State 143:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> EXISTS_OTHER lident DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> EXISTS_OTHER lident DOT expr 
-- On RIGHTPAR reduce production expr -> EXISTS_OTHER lident DOT expr 
-- On RIGHTBR reduce production expr -> EXISTS_OTHER lident DOT expr 
-- On ELSE reduce production expr -> EXISTS_OTHER lident DOT expr 
-- On COMMA reduce production expr -> EXISTS_OTHER lident DOT expr 
-- On COLON reduce production expr -> EXISTS_OTHER lident DOT expr 

State 144:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> FORALL lidents_plus_distinct DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> FORALL lidents_plus_distinct DOT expr 
-- On RIGHTPAR reduce production expr -> FORALL lidents_plus_distinct DOT expr 
-- On RIGHTBR reduce production expr -> FORALL lidents_plus_distinct DOT expr 
-- On ELSE reduce production expr -> FORALL lidents_plus_distinct DOT expr 
-- On COMMA reduce production expr -> FORALL lidents_plus_distinct DOT expr 
-- On COLON reduce production expr -> FORALL lidents_plus_distinct DOT expr 

State 145:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> FORALL_OTHER lident DOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129
-- On THEN reduce production expr -> FORALL_OTHER lident DOT expr 
-- On RIGHTPAR reduce production expr -> FORALL_OTHER lident DOT expr 
-- On RIGHTBR reduce production expr -> FORALL_OTHER lident DOT expr 
-- On ELSE reduce production expr -> FORALL_OTHER lident DOT expr 
-- On COMMA reduce production expr -> FORALL_OTHER lident DOT expr 
-- On COLON reduce production expr -> FORALL_OTHER lident DOT expr 

State 146:
expr -> expr . AND expr [ THEN OR IMP EQUIV AND ]
expr -> expr . OR expr [ THEN OR IMP EQUIV AND ]
expr -> expr . IMP expr [ THEN OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ THEN OR IMP EQUIV AND ]
expr -> IF expr . THEN expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN shift to state 147
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 147:
expr -> IF expr THEN . expr ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 148
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 148:
expr -> expr . AND expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . OR expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . IMP expr [ OR IMP EQUIV ELSE AND ]
expr -> expr . EQUIV expr [ OR IMP EQUIV ELSE AND ]
expr -> IF expr THEN expr . ELSE expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On ELSE shift to state 149
-- On AND shift to state 129

State 149:
expr -> IF expr THEN expr ELSE . expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 150
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 150:
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> IF expr THEN expr ELSE expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production expr -> IF expr THEN expr ELSE expr 
-- On RIGHTPAR reduce production expr -> IF expr THEN expr ELSE expr 
-- On RIGHTBR reduce production expr -> IF expr THEN expr ELSE expr 
-- On OR reduce production expr -> IF expr THEN expr ELSE expr 
-- On IMP reduce production expr -> IF expr THEN expr ELSE expr 
-- On EQUIV reduce production expr -> IF expr THEN expr ELSE expr 
-- On ELSE reduce production expr -> IF expr THEN expr ELSE expr 
-- On COMMA reduce production expr -> IF expr THEN expr ELSE expr 
-- On COLON reduce production expr -> IF expr THEN expr ELSE expr 
-- On AND reduce production expr -> IF expr THEN expr ELSE expr 

State 151:
expr -> expr . AND expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTPAR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTPAR OR IMP EQUIV AND ]
simple_expr -> LEFTPAR expr . RIGHTPAR [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On RIGHTPAR shift to state 152
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 152:
simple_expr -> LEFTPAR expr RIGHTPAR . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On RIGHTPAR reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On RIGHTBR reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On OR reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On IMP reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On EQUIV reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On ELSE reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On COMMA reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On COLON reduce production simple_expr -> LEFTPAR expr RIGHTPAR 
-- On AND reduce production simple_expr -> LEFTPAR expr RIGHTPAR 

State 153:
expr -> NOT expr . [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . AND expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . OR expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . IMP expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
expr -> expr . EQUIV expr [ THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND ]
-- On THEN reduce production expr -> NOT expr 
-- On RIGHTPAR reduce production expr -> NOT expr 
-- On RIGHTBR reduce production expr -> NOT expr 
-- On OR reduce production expr -> NOT expr 
-- On IMP reduce production expr -> NOT expr 
-- On EQUIV reduce production expr -> NOT expr 
-- On ELSE reduce production expr -> NOT expr 
-- On COMMA reduce production expr -> NOT expr 
-- On COLON reduce production expr -> NOT expr 
-- On AND reduce production expr -> NOT expr 

State 154:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 155
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 155:
unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INIT reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On GOOD reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On EOF reduce production unsafe -> UNSAFE LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 

State 156:
lidents_plus -> lident . [ RIGHTPAR ]
lidents_plus -> lident . lidents_plus [ RIGHTPAR ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 157
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents_plus -> lident 

State 157:
lidents_plus -> lident lidents_plus . [ RIGHTPAR ]
-- On RIGHTPAR reduce production lidents_plus -> lident lidents_plus 

State 158:
unsafe -> UNSAFE LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 159
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 159:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
unsafe -> UNSAFE LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 160
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 160:
unsafe -> UNSAFE LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On INIT reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On GOOD reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 
-- On EOF reduce production unsafe -> UNSAFE LEFTBR expr RIGHTBR 

State 161:
decl_regexp -> TREGEXP . COLON regexp [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On COLON shift to state 162

State 162:
decl_regexp -> TREGEXP COLON . regexp [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 163
-- On transition_name shift to state 164
-- On trans_list shift to state 168
-- On regexp shift to state 171
-- On mident shift to state 166
-- On lident shift to state 167

State 163:
regexp -> LEFTPAR . regexp RIGHTPAR [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 163
-- On transition_name shift to state 164
-- On trans_list shift to state 168
-- On regexp shift to state 169
-- On mident shift to state 166
-- On lident shift to state 167

State 164:
trans_list -> transition_name . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
trans_list -> transition_name . trans_list [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On transition_name shift to state 164
-- On trans_list shift to state 165
-- On mident shift to state 166
-- On lident shift to state 167
-- On UNSAFE reduce production trans_list -> transition_name 
-- On TREGEXP reduce production trans_list -> transition_name 
-- On TRANSITION reduce production trans_list -> transition_name 
-- On RIGHTPAR reduce production trans_list -> transition_name 
-- On PREDICATE reduce production trans_list -> transition_name 
-- On INVARIANT reduce production trans_list -> transition_name 
-- On INIT reduce production trans_list -> transition_name 
-- On GOOD reduce production trans_list -> transition_name 
-- On EOF reduce production trans_list -> transition_name 

State 165:
trans_list -> transition_name trans_list . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production trans_list -> transition_name trans_list 
-- On TREGEXP reduce production trans_list -> transition_name trans_list 
-- On TRANSITION reduce production trans_list -> transition_name trans_list 
-- On RIGHTPAR reduce production trans_list -> transition_name trans_list 
-- On PREDICATE reduce production trans_list -> transition_name trans_list 
-- On INVARIANT reduce production trans_list -> transition_name trans_list 
-- On INIT reduce production trans_list -> transition_name trans_list 
-- On GOOD reduce production trans_list -> transition_name trans_list 
-- On EOF reduce production trans_list -> transition_name trans_list 

State 166:
transition_name -> mident . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE MIDENT LIDENT LEFTPAR INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production transition_name -> mident 
-- On TREGEXP reduce production transition_name -> mident 
-- On TRANSITION reduce production transition_name -> mident 
-- On RIGHTPAR reduce production transition_name -> mident 
-- On PREDICATE reduce production transition_name -> mident 
-- On MIDENT reduce production transition_name -> mident 
-- On LIDENT reduce production transition_name -> mident 
-- On LEFTPAR reduce production transition_name -> mident 
-- On INVARIANT reduce production transition_name -> mident 
-- On INIT reduce production transition_name -> mident 
-- On GOOD reduce production transition_name -> mident 
-- On EOF reduce production transition_name -> mident 

State 167:
transition_name -> lident . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE MIDENT LIDENT LEFTPAR INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production transition_name -> lident 
-- On TREGEXP reduce production transition_name -> lident 
-- On TRANSITION reduce production transition_name -> lident 
-- On RIGHTPAR reduce production transition_name -> lident 
-- On PREDICATE reduce production transition_name -> lident 
-- On MIDENT reduce production transition_name -> lident 
-- On LIDENT reduce production transition_name -> lident 
-- On LEFTPAR reduce production transition_name -> lident 
-- On INVARIANT reduce production transition_name -> lident 
-- On INIT reduce production transition_name -> lident 
-- On GOOD reduce production transition_name -> lident 
-- On EOF reduce production transition_name -> lident 

State 168:
regexp -> trans_list . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production regexp -> trans_list 
-- On TREGEXP reduce production regexp -> trans_list 
-- On TRANSITION reduce production regexp -> trans_list 
-- On RIGHTPAR reduce production regexp -> trans_list 
-- On PREDICATE reduce production regexp -> trans_list 
-- On INVARIANT reduce production regexp -> trans_list 
-- On INIT reduce production regexp -> trans_list 
-- On GOOD reduce production regexp -> trans_list 
-- On EOF reduce production regexp -> trans_list 

State 169:
regexp -> LEFTPAR regexp . RIGHTPAR [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 170

State 170:
regexp -> LEFTPAR regexp RIGHTPAR . [ UNSAFE TREGEXP TRANSITION RIGHTPAR PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On TREGEXP reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On TRANSITION reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On RIGHTPAR reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On PREDICATE reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On INVARIANT reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On INIT reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On GOOD reduce production regexp -> LEFTPAR regexp RIGHTPAR 
-- On EOF reduce production regexp -> LEFTPAR regexp RIGHTPAR 

State 171:
decl_regexp -> TREGEXP COLON regexp . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl_regexp -> TREGEXP COLON regexp 
-- On TREGEXP reduce production decl_regexp -> TREGEXP COLON regexp 
-- On TRANSITION reduce production decl_regexp -> TREGEXP COLON regexp 
-- On PREDICATE reduce production decl_regexp -> TREGEXP COLON regexp 
-- On INVARIANT reduce production decl_regexp -> TREGEXP COLON regexp 
-- On INIT reduce production decl_regexp -> TREGEXP COLON regexp 
-- On GOOD reduce production decl_regexp -> TREGEXP COLON regexp 
-- On EOF reduce production decl_regexp -> TREGEXP COLON regexp 

State 172:
transition -> TRANSITION . transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On transition_name shift to state 173
-- On mident shift to state 166
-- On lident shift to state 167

State 173:
transition -> TRANSITION transition_name . LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 174

State 174:
transition -> TRANSITION transition_name LEFTPAR . lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 175
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents -> 

State 175:
transition -> TRANSITION transition_name LEFTPAR lidents . RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 176

State 176:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR . require LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On REQUIRE shift to state 177
-- On require shift to state 181
-- On LEFTBR reduce production require -> 

State 177:
require -> REQUIRE . LEFTBR expr RIGHTBR [ LEFTBR ]
-- On LEFTBR shift to state 178

State 178:
require -> REQUIRE LEFTBR . expr RIGHTBR [ LEFTBR ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 179
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 179:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
require -> REQUIRE LEFTBR expr . RIGHTBR [ LEFTBR ]
-- On RIGHTBR shift to state 180
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 180:
require -> REQUIRE LEFTBR expr RIGHTBR . [ LEFTBR ]
-- On LEFTBR reduce production require -> REQUIRE LEFTBR expr RIGHTBR 

State 181:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require . LEFTBR assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 182

State 182:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR . assigns_nondets_updates RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On MIDENT shift to state 9
-- On update shift to state 183
-- On nondet shift to state 184
-- On mident shift to state 185
-- On assigns_nondets_updates shift to state 208
-- On assignment shift to state 210
-- On assign_nondet_update shift to state 211
-- On RIGHTBR reduce production assigns_nondets_updates -> 

State 183:
assign_nondet_update -> update . [ RIGHTBR PV ]
-- On RIGHTBR reduce production assign_nondet_update -> update 
-- On PV reduce production assign_nondet_update -> update 

State 184:
assign_nondet_update -> nondet . [ RIGHTBR PV ]
-- On RIGHTBR reduce production assign_nondet_update -> nondet 
-- On PV reduce production assign_nondet_update -> nondet 

State 185:
assignment -> mident . AFFECT term [ RIGHTBR PV ]
assignment -> mident . AFFECT CASE switchs [ RIGHTBR PV ]
nondet -> mident . AFFECT DOT [ RIGHTBR PV ]
nondet -> mident . AFFECT QMARK [ RIGHTBR PV ]
update -> mident . LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident . LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term [ RIGHTBR PV ]
-- On LEFTSQ shift to state 186
-- On AFFECT shift to state 202

State 186:
update -> mident LEFTSQ . proc_name_list_plus RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ . proc_name_list_plus RIGHTSQ AFFECT term [ RIGHTBR PV ]
-- On LIDENT shift to state 6
-- On CONSTPROC shift to state 73
-- On proc_name_list_plus shift to state 187
-- On proc_name shift to state 101
-- On lident shift to state 104
-- On const_proc shift to state 105

State 187:
update -> mident LEFTSQ proc_name_list_plus . RIGHTSQ AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus . RIGHTSQ AFFECT term [ RIGHTBR PV ]
-- On RIGHTSQ shift to state 188

State 188:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ . AFFECT CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ . AFFECT term [ RIGHTBR PV ]
-- On AFFECT shift to state 189

State 189:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT . CASE switchs [ RIGHTBR PV ]
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT . term [ RIGHTBR PV ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On CASE shift to state 190
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 201
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 190:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE . switchs [ RIGHTBR PV ]
-- On BAR shift to state 191
-- On switchs shift to state 200

State 191:
switchs -> BAR . UNDERSCORE COLON term [ RIGHTBR PV ]
switchs -> BAR . switch [ RIGHTBR PV ]
switchs -> BAR . switch switchs [ RIGHTBR PV ]
-- On UNDERSCORE shift to state 192
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On switch shift to state 195
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 197
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 192:
switchs -> BAR UNDERSCORE . COLON term [ RIGHTBR PV ]
-- On COLON shift to state 193

State 193:
switchs -> BAR UNDERSCORE COLON . term [ RIGHTBR PV ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 194
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 194:
switchs -> BAR UNDERSCORE COLON term . [ RIGHTBR PV ]
-- On RIGHTBR reduce production switchs -> BAR UNDERSCORE COLON term 
-- On PV reduce production switchs -> BAR UNDERSCORE COLON term 

State 195:
switchs -> BAR switch . [ RIGHTBR PV ]
switchs -> BAR switch . switchs [ RIGHTBR PV ]
-- On BAR shift to state 191
-- On switchs shift to state 196
-- On RIGHTBR reduce production switchs -> BAR switch 
-- On PV reduce production switchs -> BAR switch 

State 196:
switchs -> BAR switch switchs . [ RIGHTBR PV ]
-- On RIGHTBR reduce production switchs -> BAR switch switchs 
-- On PV reduce production switchs -> BAR switch switchs 

State 197:
expr -> expr . AND expr [ OR IMP EQUIV COLON AND ]
expr -> expr . OR expr [ OR IMP EQUIV COLON AND ]
expr -> expr . IMP expr [ OR IMP EQUIV COLON AND ]
expr -> expr . EQUIV expr [ OR IMP EQUIV COLON AND ]
switch -> expr . COLON term [ RIGHTBR PV BAR ]
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On COLON shift to state 198
-- On AND shift to state 129

State 198:
switch -> expr COLON . term [ RIGHTBR PV BAR ]
-- On REAL shift to state 49
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 199
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 199:
switch -> expr COLON term . [ RIGHTBR PV BAR ]
-- On RIGHTBR reduce production switch -> expr COLON term 
-- On PV reduce production switch -> expr COLON term 
-- On BAR reduce production switch -> expr COLON term 

State 200:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs . [ RIGHTBR PV ]
-- On RIGHTBR reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs 
-- On PV reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT CASE switchs 

State 201:
update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term . [ RIGHTBR PV ]
-- On RIGHTBR reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term 
-- On PV reduce production update -> mident LEFTSQ proc_name_list_plus RIGHTSQ AFFECT term 

State 202:
assignment -> mident AFFECT . term [ RIGHTBR PV ]
assignment -> mident AFFECT . CASE switchs [ RIGHTBR PV ]
nondet -> mident AFFECT . DOT [ RIGHTBR PV ]
nondet -> mident AFFECT . QMARK [ RIGHTBR PV ]
-- On REAL shift to state 49
-- On QMARK shift to state 203
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On INT shift to state 56
-- On DOT shift to state 204
-- On CONSTPROC shift to state 73
-- On CASE shift to state 205
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 207
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On lident shift to state 104
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 203:
nondet -> mident AFFECT QMARK . [ RIGHTBR PV ]
-- On RIGHTBR reduce production nondet -> mident AFFECT QMARK 
-- On PV reduce production nondet -> mident AFFECT QMARK 

State 204:
nondet -> mident AFFECT DOT . [ RIGHTBR PV ]
-- On RIGHTBR reduce production nondet -> mident AFFECT DOT 
-- On PV reduce production nondet -> mident AFFECT DOT 

State 205:
assignment -> mident AFFECT CASE . switchs [ RIGHTBR PV ]
-- On BAR shift to state 191
-- On switchs shift to state 206

State 206:
assignment -> mident AFFECT CASE switchs . [ RIGHTBR PV ]
-- On RIGHTBR reduce production assignment -> mident AFFECT CASE switchs 
-- On PV reduce production assignment -> mident AFFECT CASE switchs 

State 207:
assignment -> mident AFFECT term . [ RIGHTBR PV ]
-- On RIGHTBR reduce production assignment -> mident AFFECT term 
-- On PV reduce production assignment -> mident AFFECT term 

State 208:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 209

State 209:
transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On TREGEXP reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On TRANSITION reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On PREDICATE reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On INVARIANT reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On INIT reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On GOOD reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 
-- On EOF reduce production transition -> TRANSITION transition_name LEFTPAR lidents RIGHTPAR require LEFTBR assigns_nondets_updates RIGHTBR 

State 210:
assign_nondet_update -> assignment . [ RIGHTBR PV ]
-- On RIGHTBR reduce production assign_nondet_update -> assignment 
-- On PV reduce production assign_nondet_update -> assignment 

State 211:
assigns_nondets_updates -> assign_nondet_update . [ RIGHTBR ]
assigns_nondets_updates -> assign_nondet_update . PV assigns_nondets_updates [ RIGHTBR ]
-- On PV shift to state 212
-- On RIGHTBR reduce production assigns_nondets_updates -> assign_nondet_update 

State 212:
assigns_nondets_updates -> assign_nondet_update PV . assigns_nondets_updates [ RIGHTBR ]
-- On MIDENT shift to state 9
-- On update shift to state 183
-- On nondet shift to state 184
-- On mident shift to state 185
-- On assigns_nondets_updates shift to state 213
-- On assignment shift to state 210
-- On assign_nondet_update shift to state 211
-- On RIGHTBR reduce production assigns_nondets_updates -> 

State 213:
assigns_nondets_updates -> assign_nondet_update PV assigns_nondets_updates . [ RIGHTBR ]
-- On RIGHTBR reduce production assigns_nondets_updates -> assign_nondet_update PV assigns_nondets_updates 

State 214:
function_decl -> PREDICATE . lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lident shift to state 215

State 215:
function_decl -> PREDICATE lident . LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 216

State 216:
function_decl -> PREDICATE lident LEFTPAR . lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lident_list_plus shift to state 217
-- On lident_comma_list shift to state 218
-- On lident shift to state 32
-- On RIGHTPAR reduce production lident_comma_list -> 

State 217:
lident_comma_list -> lident_list_plus . [ RIGHTPAR ]
-- On RIGHTPAR reduce production lident_comma_list -> lident_list_plus 

State 218:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 219

State 219:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 220

State 220:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 221
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 221:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 222
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 222:
function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On INIT reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On GOOD reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 
-- On EOF reduce production function_decl -> PREDICATE lident LEFTPAR lident_comma_list RIGHTPAR LEFTBR expr RIGHTBR 

State 223:
invariant -> INVARIANT . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
invariant -> INVARIANT . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 224
-- On LEFTBR shift to state 230

State 224:
invariant -> INVARIANT LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 225
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents -> 

State 225:
invariant -> INVARIANT LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 226

State 226:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 227

State 227:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 228
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 228:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 229
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 229:
invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INIT reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On GOOD reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On EOF reduce production invariant -> INVARIANT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 

State 230:
invariant -> INVARIANT LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 231
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 231:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
invariant -> INVARIANT LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 232
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 232:
invariant -> INVARIANT LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On INIT reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On GOOD reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 
-- On EOF reduce production invariant -> INVARIANT LEFTBR expr RIGHTBR 

State 233:
init -> INIT . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
init -> INIT . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 234
-- On LEFTBR shift to state 240

State 234:
init -> INIT LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 235
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents -> 

State 235:
init -> INIT LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 236

State 236:
init -> INIT LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 237

State 237:
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 238
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 238:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 239
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 239:
init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INIT reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On GOOD reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On EOF reduce production init -> INIT LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 

State 240:
init -> INIT LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 241
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 241:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
init -> INIT LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 242
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 242:
init -> INIT LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On INIT reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On GOOD reduce production init -> INIT LEFTBR expr RIGHTBR 
-- On EOF reduce production init -> INIT LEFTBR expr RIGHTBR 

State 243:
good -> GOOD . LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTPAR shift to state 244

State 244:
good -> GOOD LEFTPAR . lidents RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LIDENT shift to state 6
-- On lidents_plus shift to state 44
-- On lidents shift to state 245
-- On lident shift to state 156
-- On RIGHTPAR reduce production lidents -> 

State 245:
good -> GOOD LEFTPAR lidents . RIGHTPAR LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTPAR shift to state 246

State 246:
good -> GOOD LEFTPAR lidents RIGHTPAR . LEFTBR expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On LEFTBR shift to state 247

State 247:
good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR . expr RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On TRUE shift to state 48
-- On REAL shift to state 49
-- On NOT shift to state 50
-- On MINUS shift to state 51
-- On MIDENT shift to state 9
-- On LIDENT shift to state 6
-- On LEFTPAR shift to state 55
-- On INT shift to state 56
-- On IF shift to state 59
-- On FORALL_OTHER shift to state 60
-- On FORALL shift to state 63
-- On FALSE shift to state 66
-- On EXISTS_OTHER shift to state 67
-- On EXISTS shift to state 70
-- On CONSTPROC shift to state 73
-- On var_term shift to state 74
-- On var_or_array_term shift to state 75
-- On top_id_term shift to state 92
-- On term shift to state 93
-- On simple_expr shift to state 119
-- On proc_name shift to state 96
-- On mident shift to state 97
-- On literal shift to state 120
-- On lident shift to state 121
-- On expr shift to state 248
-- On constnum shift to state 106
-- On const_proc shift to state 105
-- On array_term shift to state 107
-- On arith_term shift to state 108

State 248:
expr -> expr . AND expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . OR expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . IMP expr [ RIGHTBR OR IMP EQUIV AND ]
expr -> expr . EQUIV expr [ RIGHTBR OR IMP EQUIV AND ]
good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr . RIGHTBR [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On RIGHTBR shift to state 249
-- On OR shift to state 127
-- On IMP shift to state 131
-- On EQUIV shift to state 133
-- On AND shift to state 129

State 249:
good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TREGEXP reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On TRANSITION reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On PREDICATE reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INVARIANT reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On INIT reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On GOOD reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 
-- On EOF reduce production good -> GOOD LEFTPAR lidents RIGHTPAR LEFTBR expr RIGHTBR 

State 250:
decl -> unsafe . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> unsafe 
-- On TREGEXP reduce production decl -> unsafe 
-- On TRANSITION reduce production decl -> unsafe 
-- On PREDICATE reduce production decl -> unsafe 
-- On INVARIANT reduce production decl -> unsafe 
-- On INIT reduce production decl -> unsafe 
-- On GOOD reduce production decl -> unsafe 
-- On EOF reduce production decl -> unsafe 

State 251:
decl -> transition . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> transition 
-- On TREGEXP reduce production decl -> transition 
-- On TRANSITION reduce production decl -> transition 
-- On PREDICATE reduce production decl -> transition 
-- On INVARIANT reduce production decl -> transition 
-- On INIT reduce production decl -> transition 
-- On GOOD reduce production decl -> transition 
-- On EOF reduce production decl -> transition 

State 252:
decl -> invariant . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> invariant 
-- On TREGEXP reduce production decl -> invariant 
-- On TRANSITION reduce production decl -> invariant 
-- On PREDICATE reduce production decl -> invariant 
-- On INVARIANT reduce production decl -> invariant 
-- On INIT reduce production decl -> invariant 
-- On GOOD reduce production decl -> invariant 
-- On EOF reduce production decl -> invariant 

State 253:
decl -> init . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> init 
-- On TREGEXP reduce production decl -> init 
-- On TRANSITION reduce production decl -> init 
-- On PREDICATE reduce production decl -> init 
-- On INVARIANT reduce production decl -> init 
-- On INIT reduce production decl -> init 
-- On GOOD reduce production decl -> init 
-- On EOF reduce production decl -> init 

State 254:
decl -> good . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> good 
-- On TREGEXP reduce production decl -> good 
-- On TRANSITION reduce production decl -> good 
-- On PREDICATE reduce production decl -> good 
-- On INVARIANT reduce production decl -> good 
-- On INIT reduce production decl -> good 
-- On GOOD reduce production decl -> good 
-- On EOF reduce production decl -> good 

State 255:
decl -> function_decl . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> function_decl 
-- On TREGEXP reduce production decl -> function_decl 
-- On TRANSITION reduce production decl -> function_decl 
-- On PREDICATE reduce production decl -> function_decl 
-- On INVARIANT reduce production decl -> function_decl 
-- On INIT reduce production decl -> function_decl 
-- On GOOD reduce production decl -> function_decl 
-- On EOF reduce production decl -> function_decl 

State 256:
decl -> decl_regexp . [ UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD EOF ]
-- On UNSAFE reduce production decl -> decl_regexp 
-- On TREGEXP reduce production decl -> decl_regexp 
-- On TRANSITION reduce production decl -> decl_regexp 
-- On PREDICATE reduce production decl -> decl_regexp 
-- On INVARIANT reduce production decl -> decl_regexp 
-- On INIT reduce production decl -> decl_regexp 
-- On GOOD reduce production decl -> decl_regexp 
-- On EOF reduce production decl -> decl_regexp 

State 257:
system -> size_proc type_defs symbold_decls decl_list . EOF [ # ]
-- On EOF shift to state 258

State 258:
system -> size_proc type_defs symbold_decls decl_list EOF . [ # ]
-- On # reduce production system -> size_proc type_defs symbold_decls decl_list EOF 

State 259:
decl_list -> decl . [ EOF ]
decl_list -> decl . decl_list [ EOF ]
-- On UNSAFE shift to state 42
-- On TREGEXP shift to state 161
-- On TRANSITION shift to state 172
-- On PREDICATE shift to state 214
-- On INVARIANT shift to state 223
-- On INIT shift to state 233
-- On GOOD shift to state 243
-- On unsafe shift to state 250
-- On transition shift to state 251
-- On invariant shift to state 252
-- On init shift to state 253
-- On good shift to state 254
-- On function_decl shift to state 255
-- On decl_regexp shift to state 256
-- On decl_list shift to state 260
-- On decl shift to state 259
-- On EOF reduce production decl_list -> decl 

State 260:
decl_list -> decl decl_list . [ EOF ]
-- On EOF reduce production decl_list -> decl decl_list 

State 261:
type_defs -> type_def_plus . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production type_defs -> type_def_plus 
-- On UNSAFE reduce production type_defs -> type_def_plus 
-- On TREGEXP reduce production type_defs -> type_def_plus 
-- On TRANSITION reduce production type_defs -> type_def_plus 
-- On PREDICATE reduce production type_defs -> type_def_plus 
-- On INVARIANT reduce production type_defs -> type_def_plus 
-- On INIT reduce production type_defs -> type_def_plus 
-- On GOOD reduce production type_defs -> type_def_plus 
-- On CONST reduce production type_defs -> type_def_plus 
-- On ARRAY reduce production type_defs -> type_def_plus 

State 262:
type_def_plus -> type_def . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
type_def_plus -> type_def . type_def_plus [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On TYPE shift to state 5
-- On type_def_plus shift to state 263
-- On type_def shift to state 262
-- On VAR reduce production type_def_plus -> type_def 
-- On UNSAFE reduce production type_def_plus -> type_def 
-- On TREGEXP reduce production type_def_plus -> type_def 
-- On TRANSITION reduce production type_def_plus -> type_def 
-- On PREDICATE reduce production type_def_plus -> type_def 
-- On INVARIANT reduce production type_def_plus -> type_def 
-- On INIT reduce production type_def_plus -> type_def 
-- On GOOD reduce production type_def_plus -> type_def 
-- On CONST reduce production type_def_plus -> type_def 
-- On ARRAY reduce production type_def_plus -> type_def 

State 263:
type_def_plus -> type_def type_def_plus . [ VAR UNSAFE TREGEXP TRANSITION PREDICATE INVARIANT INIT GOOD CONST ARRAY ]
-- On VAR reduce production type_def_plus -> type_def type_def_plus 
-- On UNSAFE reduce production type_def_plus -> type_def type_def_plus 
-- On TREGEXP reduce production type_def_plus -> type_def type_def_plus 
-- On TRANSITION reduce production type_def_plus -> type_def type_def_plus 
-- On PREDICATE reduce production type_def_plus -> type_def type_def_plus 
-- On INVARIANT reduce production type_def_plus -> type_def type_def_plus 
-- On INIT reduce production type_def_plus -> type_def type_def_plus 
-- On GOOD reduce production type_def_plus -> type_def type_def_plus 
-- On CONST reduce production type_def_plus -> type_def type_def_plus 
-- On ARRAY reduce production type_def_plus -> type_def type_def_plus 

